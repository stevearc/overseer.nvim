*overseer.txt*
*Overseer* *overseer* *overseer.nvim*
--------------------------------------------------------------------------------
CONTENTS                                                       *overseer-contents*

  1. Commands                                              |overseer-commands|
  2. Options                                                |overseer-options|
  3. Highlights                                          |overseer-highlights|
  4. Api                                                        |overseer-api|
  5. Keymaps                                                |overseer-keymaps|
  6. Components                                          |overseer-components|
  7. Parameters                                              |overseer-params|
  8. Actions                                                |overseer-actions|

--------------------------------------------------------------------------------
COMMANDS                                                       *overseer-commands*

OverseerOpen[!] `left/right/bottom`                                  *:OverseerOpen*
    Open the overseer window. With `!` cursor stays in current window

OverseerClose                                                     *:OverseerClose*
    Close the overseer window

OverseerToggle[!] `left/right/bottom`                              *:OverseerToggle*
    Toggle the overseer window. With `!` cursor stays in current window

OverseerRun `[name/tags]`                                             *:OverseerRun*
    Run a task from a template

OverseerShell[!] `[command]`                                        *:OverseerShell*
    Run a shell command as an overseer task. With `!` the task is created but
    not started

OverseerTaskAction                                           *:OverseerTaskAction*
    Select a task to run an action on

--------------------------------------------------------------------------------
OPTIONS                                                         *overseer-options*

>lua
    require("overseer").setup({
      -- Patch nvim-dap to support preLaunchTask and postDebugTask
      dap = true,
      -- Configure the task output buffer and window
      output = {
        -- Use a terminal buffer to display output. If false, a normal buffer is used
        use_terminal = true,
        -- If true, don't clear the buffer when a task restarts
        preserve_output = false,
      },
      -- Configure the task list
      task_list = {
        -- Default direction. Can be "left", "right", or "bottom"
        direction = "bottom",
        -- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_width and max_width can be a single value or a list of mixed integer/float types.
        -- max_width = {100, 0.2} means "the lesser of 100 columns or 20% of total"
        max_width = { 100, 0.2 },
        -- min_width = {40, 0.1} means "the greater of 40 columns or 10% of total"
        min_width = { 40, 0.1 },
        max_height = { 20, 0.2 },
        min_height = 8,
        -- String that separates tasks
        separator = "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
        -- Indentation for child tasks
        child_indent = { "┃ ", "┣━", "┗━" },
        -- Function that renders tasks. See lua/overseer/render.lua for built-in options
        -- and for useful functions if you want to build your own.
        render = function(task)
          return require("overseer.render").format_standard(task)
        end,
        -- The sort function for tasks
        sort = function(a, b)
          return require("overseer.task_list").default_sort(a, b)
        end,
        -- Set keymap to false to remove default behavior
        -- You can add custom keymaps here as well (anything vim.keymap.set accepts)
        keymaps = {
          ["?"] = "keymap.show_help",
          ["g?"] = "keymap.show_help",
          ["<CR>"] = "keymap.run_action",
          ["dd"] = { "keymap.run_action", opts = { action = "dispose" }, desc = "Dispose task" },
          ["<C-e>"] = { "keymap.run_action", opts = { action = "edit" }, desc = "Edit task" },
          ["o"] = "keymap.open",
          ["<C-v>"] = { "keymap.open", opts = { dir = "vsplit" }, desc = "Open task output in vsplit" },
          ["<C-s>"] = { "keymap.open", opts = { dir = "split" }, desc = "Open task output in split" },
          ["<C-t>"] = { "keymap.open", opts = { dir = "tab" }, desc = "Open task output in tab" },
          ["<C-f>"] = { "keymap.open", opts = { dir = "float" }, desc = "Open task output in float" },
          ["<C-q>"] = {
            "keymap.run_action",
            opts = { action = "open output in quickfix" },
            desc = "Open task output in the quickfix",
          },
          ["p"] = "keymap.toggle_preview",
          ["{"] = "keymap.prev_task",
          ["}"] = "keymap.next_task",
          ["<C-k>"] = "keymap.scroll_output_up",
          ["<C-j>"] = "keymap.scroll_output_down",
          ["g."] = "keymap.toggle_show_wrapped",
          ["q"] = { "<CMD>close<CR>", desc = "Close task list" },
        },
      },
      -- Custom actions for tasks. See :help overseer-actions
      actions = {},
      -- Configure the floating window used for task templates that require input
      -- and the floating window used for editing tasks
      form = {
        zindex = 40,
        -- Dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_X and max_X can be a single value or a list of mixed integer/float types.
        min_width = 80,
        max_width = 0.9,
        min_height = 10,
        max_height = 0.9,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {},
      },
      -- Configuration for task floating output windows
      task_win = {
        -- How much space to leave around the floating window
        padding = 2,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {},
      },
      -- Aliases for bundles of components. Redefine the builtins, or create your own.
      component_aliases = {
        -- Most tasks are initialized with the default components
        default = {
          "on_exit_set_status",
          "on_complete_notify",
          { "on_complete_dispose", require_view = { "SUCCESS", "FAILURE" } },
        },
        -- Tasks from tasks.json use these components
        default_vscode = {
          "default",
          "on_result_diagnostics",
        },
        -- Tasks created from experimental_wrap_builtins
        default_builtin = {
          "on_exit_set_status",
          "on_complete_dispose",
          { "unique", soft = true },
        },
      },
      -- List of other directories to search for task templates.
      -- This will search under the runtimepath, so for example
      -- "foo/bar" will search "<runtimepath>/lua/foo/bar/*"
      template_dirs = {},
      -- For template providers, how long to wait before timing out.
      -- Set to 0 to wait forever.
      template_timeout_ms = 3000,
      -- Cache template provider results if the provider takes longer than this to run.
      -- Set to 0 to disable caching.
      template_cache_threshold_ms = 200,
      log_level = vim.log.levels.WARN,
      -- Overseer can wrap any call to vim.system and vim.fn.jobstart as a task.
      experimental_wrap_builtins = {
        enabled = false,
        condition = function(cmd, caller, opts)
          return true
        end,
      },
    })
<

--------------------------------------------------------------------------------
HIGHLIGHTS                                                   *overseer-highlights*

OverseerPENDING                                               *hl-OverseerPENDING*
    Pending tasks

OverseerRUNNING                                               *hl-OverseerRUNNING*
    Running tasks

OverseerSUCCESS                                               *hl-OverseerSUCCESS*
    Succeeded tasks

OverseerCANCELED                                             *hl-OverseerCANCELED*
    Canceled tasks

OverseerFAILURE                                               *hl-OverseerFAILURE*
    Failed tasks

OverseerTask                                                     *hl-OverseerTask*
    Used to render the name of a task or template

OverseerTaskBorder                                         *hl-OverseerTaskBorder*
    The separator in the task list

OverseerOutput                                                 *hl-OverseerOutput*
    The output summary in the task list

OverseerComponent                                           *hl-OverseerComponent*
    The name of a component in the task list or task editor

OverseerField                                                   *hl-OverseerField*
    The name of a field in the task or template editor

--------------------------------------------------------------------------------
API                                                                 *overseer-api*

setup({opts})                                                     *overseer.setup*
    Initialize overseer

    Parameters:
      {opts} `overseer.SetupOpts|nil` Configuration options

new_task({opts}): overseer.Task                                *overseer.new_task*
    Create a new Task

    Parameters:
      {opts} `overseer.TaskDefinition`
          {cmd}        `string|string[]` Command to run. If it's a string it is
                       run in the shell; a table is run directly
          {args}       `nil|string[]` Arguments to pass to the command
          {name}       `nil|string` Name of the task. Defaults to the cmd
          {cwd}        `nil|string` Working directory to run in
          {env}        `nil|table<string, string>` Additional environment
                       variables
          {strategy}   `nil|overseer.Serialized` Definition for a run Strategy
          {metadata}   `nil|table` Arbitrary metadata for your own use
          {default_component_params} `nil|table<string, any>` Default values for
                       component params
          {components} `nil|overseer.Serialized[]` List of components to attach.
                       Defaults to `{"default"}`
          {ephemeral}  `nil|boolean` Indicates that this task was generated by
                       another task (e.g. with run_after)

    Examples: >lua
      local task = overseer.new_task({
        cmd = { "./build.sh", "all" },
        components = { { "on_output_quickfix", open = true }, "default" }
      })
      task:start()
<

toggle({opts})                                                   *overseer.toggle*
    Open or close the task list

    Parameters:
      {opts} `nil|overseer.WindowOpts`
          {enter}         `nil|boolean` Focus the task list window after opening
                          (default true)
          {direction}     `nil|"left"|"right"|"bottom"`
          {winid}         `nil|integer` Use this existing window instead of
                          opening a new window
          {focus_task_id} `nil|integer` After opening, focus this task

open({opts})                                                       *overseer.open*
    Open the task list

    Parameters:
      {opts} `nil|overseer.WindowOpts`
          {enter}         `nil|boolean` Focus the task list window after opening
                          (default true)
          {direction}     `nil|"left"|"right"|"bottom"`
          {winid}         `nil|integer` Use this existing window instead of
                          opening a new window
          {focus_task_id} `nil|integer` After opening, focus this task

close()                                                           *overseer.close*
    Close the task list


list_tasks({opts}): overseer.Task[]                          *overseer.list_tasks*
    List all tasks

    Parameters:
      {opts} `nil|overseer.ListTaskOpts`
          {unique}  `nil|boolean` Deduplicates non-running tasks by name
          {status}  `nil|overseer.Status|overseer.Status[]` Only list tasks with
                    this status or statuses
          {include_ephemeral} `nil|boolean` Include ephemeral tasks
          {wrapped} `nil|boolean` Include tasks that were created by the
                    jobstart/vim.system wrappers
          {filter}  `nil|fun(task: overseer.Task): boolean` Only include tasks
                    where this function returns true
          {sort}    `nil|fun(a: overseer.Task, b: overseer.Task): boolean` Funct
                    ion that sorts tasks

run_task({opts}, {callback})                                   *overseer.run_task*
    Run a task from a template

    Parameters:
      {opts}     `overseer.TemplateRunOpts`
          {name}            `nil|string` The name of the template to run
          {tags}            `nil|string[]` List of tags used to filter when
                            searching for template
          {autostart}       `nil|boolean` When true, start the task after
                            creating it (default true)
          {first}           `nil|boolean` When true, take first result and never
                            show the task picker. Default behavior will auto-set
                            this based on presence of name and tags
          {params}          `nil|table` Parameters to pass to template
          {cwd}             `nil|string` Working directory for the task
          {env}             `nil|table<string, string>` Additional environment
                            variables for the task
          {disallow_prompt} `nil|boolean` When true, if any required parameters
                            are missing return an error instead of prompting the
                            user for them
          {on_build}        `nil|fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`
                            callback that is called after the task definition is
                            built but before the task is created.
      {callback} `nil|fun(task: overseer.Task|nil, err: string|nil)`

    Examples: >lua
      -- Run the task named "make all"
      -- equivalent to :OverseerRun make\ all
      overseer.run_task({name = "make all"})
      -- Run the default "build" task
      -- equivalent to :OverseerRun BUILD
      overseer.run_task({tags = {overseer.TAG.BUILD}})
      -- Run the task named "serve" with some default parameters
      overseer.run_task({name = "serve", params = {port = 8080}})
      -- Create a task but do not start it
      overseer.run_task({name = "make", autostart = false}, function(task)
        -- do something with the task
      end)
      -- Run a task and immediately open the floating window
      overseer.run_task({name = "make"}, function(task)
        if task then
          overseer.run_action(task, 'open float')
        end
      end)
<

preload_task_cache({opts}, {cb})                     *overseer.preload_task_cache*
    Preload templates for run_task

    Parameters:
      {opts} `nil|overseer.SearchParams`
          {filetype} `nil|string`
          {tags}     `nil|string[]`
          {dir}      `string`
      {cb}   `nil|fun()` Called when preloading is complete

    Note:
      Typically this would be done to prevent a long wait time for :OverseerRun when using a slow
      template provider.

    Examples: >lua
      -- Automatically preload templates for the current directory
      vim.api.nvim_create_autocmd({"VimEnter", "DirChanged"}, {
        local cwd = vim.v.cwd or vim.fn.getcwd()
        require("overseer").preload_task_cache({ dir = cwd })
      })
<

clear_task_cache({opts})                               *overseer.clear_task_cache*
    Clear cached templates for run_task

    Parameters:
      {opts} `nil|overseer.SearchParams`
          {filetype} `nil|string`
          {tags}     `nil|string[]`
          {dir}      `string`

run_action({task}, {name})                                   *overseer.run_action*
    Run an action on a task

    Parameters:
      {task} `overseer.Task`
      {name} `nil|string` Name of action. When omitted, prompt user to pick.

add_template_hook({opts}, {hook})                     *overseer.add_template_hook*
    Add a hook that runs on a TaskDefinition before the task is created

    Parameters:
      {opts} `nil|overseer.HookOptions` When nil, run the hook on all templates
          {module} `nil|string` Only run if the template module matches this
                   pattern (using string.match)
          {name}   `nil|string` Only run if the template name matches this
                   pattern (using string.match)
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      -- Add on_output_quickfix component to all "cargo" templates
      overseer.add_template_hook({ module = "^cargo$" }, function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end)
      -- Remove the on_complete_notify component from "cargo clean" task
      overseer.add_template_hook({ name = "cargo clean" }, function(task_defn, util)
        util.remove_component(task_defn, "on_complete_notify")
      end)
      -- Add an environment variable for all go tasks in a specific dir
      overseer.add_template_hook({ name = "^go .*", dir = "/path/to/project" }, function(task_defn, util)
        task_defn.env = vim.tbl_extend('force', task_defn.env or {}, {
          GO111MODULE = "on"
        })
      end)
<

remove_template_hook({opts}, {hook})               *overseer.remove_template_hook*
    Remove a hook that was added with add_template_hook

    Parameters:
      {opts} `nil|overseer.HookOptions` Same as for add_template_hook
          {module} `nil|string` Only run if the template module matches this
                   pattern (using string.match)
          {name}   `nil|string` Only run if the template name matches this
                   pattern (using string.match)
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      local opts = {module = "cargo"}
      local hook = function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end
      overseer.add_template_hook(opts, hook)
      -- Remove should pass in the same opts as add
      overseer.remove_template_hook(opts, hook)
<

register_template({defn})                             *overseer.register_template*
    Directly register an overseer template

    Parameters:
      {defn} `overseer.TemplateDefinition|overseer.TemplateProvider`

    Examples: >lua
      overseer.register_template({
        name = "My Task",
        builder = function(params)
          return {
            cmd = { "echo", "Hello", "world" },
          }
        end,
      })
<

register_alias({name}, {components}, {override})         *overseer.register_alias*
    Register a new component alias.

    Parameters:
      {name}       `string`
      {components} `overseer.Serialized[]`
      {override}   `nil|boolean` When true, override any existing alias with the
                   same name

    Note:
      This is intended to be used by plugin authors that wish to build on top of overseer. They do not
      have control over the call to overseer.setup(), so this provides an alternative method of
      setting a component alias that they can then use when creating tasks.

    Examples: >lua
      require("overseer").register_alias("my_plugin", { "default", "on_output_quickfix" })
<

create_task_output_view({winid}, {opts})        *overseer.create_task_output_view*
    Set a window to display the output of a dynamically-chosen task

    Parameters:
      {winid} `nil|integer` The window to use for displaying the task output
      {opts}  `nil|overseer.TaskViewOpts`
          {select}         `nil|fun(self: overseer.TaskView, tasks: overseer.Task[], task_under_cursor?: overseer.Task): nil|overseer.Task`
                           Select which task in the task list to display the
                           output of
          {close_on_list_close} `nil|boolean` Close the window when the task
                           list is closed
          {list_task_opts} `nil|overseer.ListTaskOpts` Passed to list_tasks() to
                           get the list of tasks to pass to the select()
                           function
              {unique}  `nil|boolean` Deduplicates non-running tasks by name
              {status}  `nil|overseer.Status|overseer.Status[]` Only list tasks
                        with this status or statuses
              {include_ephemeral} `nil|boolean` Include ephemeral tasks
              {wrapped} `nil|boolean` Include tasks that were created by the
                        jobstart/vim.system wrappers
              {filter}  `nil|fun(task: overseer.Task): boolean` Only include
                        tasks where this function returns true
              {sort}    `nil|fun(a: overseer.Task, b: overseer.Task): boolean` F
                        unction that sorts tasks

    Examples: >lua
      -- Always show the output from the most recent Neotest task in this window.
      -- Close it automatically when all test tasks are disposed.
      overseer.create_task_output_view(0, {
        select = function(self, tasks, task_under_cursor)
          for _, task in ipairs(tasks) do
            if task.metadata.neotest_group_id then
              return task
            end
          end
          self:dispose()
        end,
      })
<

overseer.Task                                                      *overseer.Task*

    Fields:
      {id}            `integer` Unique ID for this task
      {result}        `nil|table<string, any>` For successful tasks, arbitrary
                      key-value mapping of data produced by components
      {metadata}      `table<string, any>` Arbitrary key-value mapping passed by
                      the user during construction
      {status}        `overseer.Status` Current task status
      {cmd}           `string|string[]` Command to run. If it's a string it is
                      run in the shell
      {cwd}           `string` Working directory the task is run in
      {env}           `nil|table<string, string>` Additional environment
                      variables for the task
      {name}          `string` Name of the task
      {ephemeral}     `boolean` Indicates that this task was generated
                      indirectly (e.g. with run_after)
      {source}        `nil|overseer.Caller` If this task was created by wrapping
                      jobstart/vim.system, this contains information about the
                      callsite
      {exit_code}     `nil|integer` Exit code of the task process
      {parent_id}     `nil|integer` ID of parent task. Used only to visually
                      group tasks in the task list
      {time_start}    `nil|integer` Timestamp when the task was started
                      (os.time())
      {time_end}      `nil|integer` Timestamp when the task ended (os.time())



Task:clone(): overseer.Task                                  *overseer.Task:clone*
    Create a deep copy of this task


Task:add_component({comp})                           *overseer.Task:add_component*
    Add a component, no-op if it already exists

    Parameters:
      {comp} `overseer.Serialized`

Task:add_components({components})                   *overseer.Task:add_components*
    Add components, skipping any that already exist

    Parameters:
      {components} `overseer.Serialized[]`

Task:set_component({comp})                           *overseer.Task:set_component*
    Add component, overwriting any existing

    Parameters:
      {comp} `overseer.Serialized`

Task:set_components({components})                   *overseer.Task:set_components*
    Add components, overwriting any existing

    Parameters:
      {components} `overseer.Serialized[]`

Task:get_component({name}): nil|overseer.Component   *overseer.Task:get_component*

    Parameters:
      {name} `string`

Task:remove_component({name}): nil|overseer.Component *overseer.Task:remove_component*

    Parameters:
      {name} `string`

Task:remove_components({names}): overseer.Component[] *overseer.Task:remove_components*

    Parameters:
      {names} `string[]`

Task:has_component({name}): boolean                  *overseer.Task:has_component*

    Parameters:
      {name} `string`

Task:subscribe({event}, {callback})                      *overseer.Task:subscribe*
    Subscribe to events on this task

    Parameters:
      {event}    `string`
      {callback} `fun(task: overseer.Task, ...: any): nil|boolean` Callback can
                 return a truthy value to unsubscribe itself

    Note:
      Listeners cannot be serialized, so will not be saved when saving task
      to disk and will not be copied when cloning the task.

Task:unsubscribe({event}, {callback})                  *overseer.Task:unsubscribe*
    Unsubscribe from an event that was previously subscribed to

    Parameters:
      {event}    `string`
      {callback} `fun(task: overseer.Task, ...: any)`

Task:is_pending(): boolean                              *overseer.Task:is_pending*
    Returns true if the task is PENDING


Task:is_running(): boolean                              *overseer.Task:is_running*
    Returns true if the task is RUNNING


Task:is_complete(): boolean                            *overseer.Task:is_complete*
    Returns true if the task is complete (not PENDING or RUNNING)


Task:is_disposed(): boolean                            *overseer.Task:is_disposed*
    Returns true if the task is DISPOSED


Task:get_bufnr(): number|nil                             *overseer.Task:get_bufnr*
    Get the buffer containing the task output. Will be nil if task is PENDING.


Task:open_output({direction})                          *overseer.Task:open_output*
    Open the task output in a window

    Parameters:
      {direction} `nil|"float"|"tab"|"vertical"|"horizontal"`

    Note:
      You can also use get_bufnr() to get the buffer and open it however you like.

Task:broadcast({name})                                   *overseer.Task:broadcast*
    Dispatch an event to all other tasks

    Parameters:
      {name} `string`

Task:dispatch({name}): any[]                              *overseer.Task:dispatch*
    Dispatch an event to all components

    Parameters:
      {name} `string`

Task:inc_reference()                                 *overseer.Task:inc_reference*
    Increment the refcount for this Task, preventing it from being disposed
    (unless force=true)


Task:dec_reference()                                 *overseer.Task:dec_reference*
    Decrement the refcount for this Task


Task:dispose({force}): boolean                             *overseer.Task:dispose*
    Cleans up resources, removes from task list, and deletes buffer.

    Parameters:
      {force} `nil|boolean` When true, will dispose even with a nonzero refcount
              or when buffer is visible
    Returns:
      `boolean` disposed True if task was disposed

Task:restart({force_stop}): boolean                        *overseer.Task:restart*
    Reset and re-run the task

    Parameters:
      {force_stop} `nil|boolean` If true, restart the Task even if it is
                   currently running

Task:start()                                                 *overseer.Task:start*
    Start a pending task


Task:stop(): boolean                                          *overseer.Task:stop*
    Stop a running task

    Returns:
      `boolean` stopped True if the task was stopped

--------------------------------------------------------------------------------
KEYMAPS                                                         *overseer-keymaps*

The `task_list.keymaps` option in `overseer.setup` allow you to create mappings
using all the same parameters as |vim.keymap.set|.
>lua
    keymaps = {
        -- Mappings can be a string
        ["<CR>"] = "<CMD>lua require('overseer').run_action()<CR>",
        -- Mappings can be a function
        gd = function()
            for _, task in ipairs(require("overseer").list_tasks()) do
                task:dispose()
            end
        end,
        -- You can pass additional opts to vim.keymap.set by using
        -- a table with the mapping as the first element.
        gd = {
            function()
                for _, task in ipairs(require("overseer").list_tasks()) do
                    task:dispose()
                end
            end,
            mode = "n",
            nowait = true,
            desc = "Dispose all tasks"
        },
        -- Mappings that are a string starting with "keymap." will be
        -- one of the built-in keymaps, documented below.
        p = "keymap.toggle_preview",
        -- Some keymaps have parameters. These are passed in via the `opts` key.
        dd = { "keymap.run_action", opts = { action = "dispose" }, desc = "Dispose task" },
    }

Below are the mappings that can be used in the `keymaps` section of config
options. You can refer to them as strings (e.g. "keymaps.<map_name>")

next_task                                                      *keymaps.next_task*
    Jump to next task

open                                                                *keymaps.open*
    Open task output

    Parameters:
      {dir} `"split"|"vsplit"|"tab"|"float"` type of window to open the task
            output in

prev_task                                                      *keymaps.prev_task*
    Jump to previous task

run_action                                                    *keymaps.run_action*
    Run an action on the current task

    Parameters:
      {action} `string` Run an action on the current task

scroll_output_down                                    *keymaps.scroll_output_down*
    Scroll down in the task output window

scroll_output_up                                        *keymaps.scroll_output_up*
    Scroll up in the task output window

show_help                                                      *keymaps.show_help*
    Show default keymaps

toggle_preview                                            *keymaps.toggle_preview*
    Toggle task output in a preview floating window

toggle_show_wrapped                                  *keymaps.toggle_show_wrapped*
    Toggle showing wrapped builtin jobstart/vim.system tasks

--------------------------------------------------------------------------------
COMPONENTS                                                   *overseer-components*

dependencies                                                        *dependencies*
    Set dependencies for task

    Parameters:
      {sequential} `boolean` (default `false`)
      {tasks}      `list[string]` Names of dependency task templates This can be
                   a list of strings (template names, e.g. "cargo build"),
                   tables (template name with params, e.g. {"mytask", foo =
                   "bar"}), or tables (raw task params, e.g. {cmd = "sleep 10"})

on_complete_dispose                                          *on_complete_dispose*
    After task is completed, dispose it after a timeout

    Parameters:
      {require_view} `list[enum]` Tasks with these statuses must be viewed
                     before they will be disposed (default `[]`)
      {statuses}     `list[enum]` Tasks with one of these statuses will be
                     disposed (default `["SUCCESS", "FAILURE", "CANCELED"]`)
      {timeout}      `number` Time to wait (in seconds) before disposing
                     (default `300`)

on_complete_notify                                            *on_complete_notify*
    vim.notify when task is completed

    Parameters:
      {on_change} `boolean` Only notify when task status changes from previous
                  value (default `false`) This is mostly used when a task is
                  going to be restarted, and you want notifications only when it
                  goes from SUCCESS to FAILURE, or vice-versa
      {statuses}  `list[enum]` List of statuses to notify on (default
                  `["FAILURE", "SUCCESS"]`)
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

on_complete_restart                                          *on_complete_restart*
    Restart task when it completes

    Parameters:
      {delay}    `number` How long to wait (in ms) post-result before triggering
                 restart (default `500`)
      {statuses} `list[enum]` What statuses will trigger a restart (default
                 `["FAILURE"]`)

on_exit_set_status                                            *on_exit_set_status*
    Sets final task status based on exit code

    Parameters:
      {success_codes} `list[integer]` Additional exit codes to consider as
                      success

on_output_notify                                                *on_output_notify*
    Use nvim-notify to show notification with task output summary for long-running tasks
    Works like on_complete_notify but, for long-running commands, also shows
    real-time output summary. Requires nvim-notify to modify the last
    notification window when new output arrives instead of creating new
    notification.

    Parameters:
      {delay_ms}  `number` Time in milliseconds to wait before displaying the
                  notification during task runtime (default `2000`)
      {max_lines} `integer` Number of lines of output to show (default `1`)
      {max_width} `integer` Maximum output width (default `49`)
      {output_on_complete} `boolean` Show the last lines of task output and
                  status on completion (instead of only the status) (default
                  `false`) When output_on_complete==true: shows status + last
                  output lines during task runtime and after completion. When
                  output_on_complete==false: shows status + last output lines
                  during task runtime and only status after completion.
      {trim}      `boolean` Remove whitespace from both sides of each line
                  (default `true`)

on_output_parse                                                  *on_output_parse*
    Parses task output and sets task result

    Parameters:
      {parser}          `opaque` Parse function or overseer.OutputParser This
                        can be a function that takes a line of output and
                        (optionally) returns a quickfix-list item (see :help
                        |setqflist-what|). For more complex parsing, this should
                        be a class of type overseer.OutputParser.
      {problem_matcher} `opaque` VS Code-style problem matcher Only one of
                        'parser', 'problem_matcher', or 'errorformat' is
                        allowed.
      {errorformat}     `opaque` Errorformat string Only one of 'parser',
                        'problem_matcher', or 'errorformat' is allowed.
      {precalculated_vars} `opaque` Precalculated VS Code task variables Tasks
                        that are started from the VS Code provider precalculate
                        certain interpolated variables (e.g.
                        ${workspaceFolder}). We pass those in as params so they
                        will remain stable even if Neovim's state changes in
                        between creating and running (or restarting) the task.
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)

on_output_quickfix                                            *on_output_quickfix*
    Set all task output into the quickfix (on complete)

    Parameters:
      {close}           `boolean` Close the quickfix on completion if no
                        errorformat matches (default `false`)
      {errorformat}     `string` See :help errorformat
      {items_only}      `boolean` Only show lines that match the errorformat
                        (default `false`)
      {open}            `boolean` Open the quickfix on output (default `false`)
      {open_height}     `integer` The height of the quickfix when opened
      {open_on_exit}    `enum` Open the quickfix when the command exits (default
                        `"never"`) (choices: `"never"|"failure"|"always"`)
      {open_on_match}   `boolean` Open the quickfix when the errorformat finds a
                        match (default `false`)
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)
      {set_diagnostics} `boolean` Add the matching items to vim.diagnostics
                        (default `false`)
      {tail}            `boolean` Update the quickfix with task output as it
                        happens, instead of waiting until completion (default
                        `true`) This may cause unexpected results for commands
                        that produce "fancy" output using terminal escape codes
                        (e.g. animated progress indicators)

on_output_write_file                                        *on_output_write_file*
    Write task output to a file

    Parameters:
      {*filename} `string` Name of file to write output to

on_result_diagnostics                                      *on_result_diagnostics*
    If task result contains diagnostics, display them

    Parameters:
      {remove_on_restart} `boolean` Remove diagnostics when task restarts
      {signs}        `boolean` Override the default diagnostics.signs setting
      {underline}    `boolean` Override the default diagnostics.underline
                     setting
      {virtual_text} `boolean` Override the default diagnostics.virtual_text
                     setting

on_result_diagnostics_quickfix                    *on_result_diagnostics_quickfix*
    If task result contains diagnostics, add them to the quickfix

    Parameters:
      {close}       `boolean` If true, close the quickfix when there are no
                    diagnostics (default `false`)
      {open}        `boolean` If true, open the quickfix when there are
                    diagnostics (default `false`)
      {set_empty_results} `boolean` If true, overwrite the current quickfix even
                    if there are no diagnostics (default `false`)
      {use_loclist} `boolean` If true, use the loclist instead of quickfix
                    (default `false`)

on_result_diagnostics_trouble                      *on_result_diagnostics_trouble*
    If task result contains diagnostics, open trouble.nvim

    Parameters:
      {args}  `list[string]` Arguments passed to 'Trouble diagnostics open'
      {close} `boolean` If true, close Trouble when there are no diagnostics
              (default `false`)

on_result_notify                                                *on_result_notify*
    vim.notify when task receives results
    Normally you will want to use on_complete_notify. If you have a long-running
    watch task (e.g. `tsc --watch`) that produces new results periodically, then
    this is the component you want.

    Parameters:
      {infer_status_from_diagnostics} `boolean` Notification level will be
                  error/info depending on if diagnostics are present (default
                  `true`)
      {on_change} `boolean` Only notify when status changes from previous value
                  (default `true`) This only works when
                  infer_status_from_diagnostics = true
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

open_output                                                          *open_output*
    Open task output

    Parameters:
      {direction}   `enum` Where to open the task output (default `"dock"`) The
                    'dock' option will open the output docked to the bottom next
                    to the task list. (choices:
                    `"dock"|"float"|"tab"|"vertical"|"horizontal"`)
      {focus}       `boolean` Focus the output window when it is opened (default
                    `false`)
      {on_complete} `enum` Open the output when the task completes (default
                    `"never"`) (choices: `"always"|"never"|"success"|"failure"`)
      {on_result}   `enum` Open the output when the task produces a result
                    (default `"never"`) (choices:
                    `"always"|"never"|"if_diagnostics"`)
      {on_start}    `enum` Open the output when the task starts (default
                    `"if_no_on_output_quickfix"`) The 'if_no_on_output_quickfix'
                    option will open the task output on start unless the task
                    has the 'on_output_quickfix' component attached. (choices:
                    `"always"|"never"|"if_no_on_output_quickfix"`)

restart_on_save                                                  *restart_on_save*
    Restart on any buffer :write

    Parameters:
      {delay}     `number` How long to wait (in ms) before triggering restart
                  (default `500`)
      {interrupt} `boolean` Interrupt running tasks. If false, will wait for
                  task to complete before restarting (default `true`)
      {mode}      `enum` How to watch the paths (default `"autocmd"`) 'autocmd'
                  will set autocmds on BufWritePost. 'uv' will use a libuv file
                  watcher (recursive watching may not be supported on all
                  platforms). (choices: `"autocmd"|"uv"`)
      {paths}     `list[string]` Only restart when writing files in these paths
                  (can be directory or file)

run_after                                                              *run_after*
    Run other tasks after this task completes

    Parameters:
      {detach}   `boolean` Tasks created will not be linked to the parent task
                 (default `false`) This means they will not restart when the
                 parent restarts, and will not be disposed when the parent is
                 disposed
      {statuses} `list[enum]` Only run successive tasks if the final status is
                 in this list (default `["SUCCESS"]`)
      {tasks}    `list[string]` Names of dependency task templates This can be a
                 list of strings (template names, e.g. "cargo build"), tables
                 (template name with params, e.g. {"mytask", foo = "bar"}), or
                 tables (raw task params, e.g. {cmd = "sleep 10"})

timeout                                                                  *timeout*
    Cancel task if it exceeds a timeout

    Parameters:
      {timeout} `integer` Time to wait (in seconds) before canceling (default
                `120`)

unique                                                                    *unique*
    Ensure that this task does not have any duplicates

    Parameters:
      {replace} `boolean` If a prior task exists, replace it. When false, will
                restart the existing task and dispose the current task (default
                `true`) Note that when this is false a new task that is created
                will restart the existing one and _dispose itself_. This can
                lead to unexpected behavior if you are creating a task and then
                trying to use that reference (to run actions on it, use it as a
                dependency, etc)
      {restart_interrupts} `boolean` When replace = false, should restarting the
                existing task interrupt it (default `true`)
      {soft}    `boolean` Only dispose duplicate tasks if they are completed.
                Implies replace = true. (default `false`)

--------------------------------------------------------------------------------
PARAMETERS                                                       *overseer-params*

Parameters are a schema-defined set of options. They are used by both components
and templates to expose customization options.

>lua
    local params = {
      my_var = {
        type = "string",
        -- Optional fields that are available on any type
        name = "More readable name",
        desc = "A detailed description",
        order = 1, -- determines order of parameters in the UI
        validate = function(value)
          return true
        end,
        optional = true,
        default = "foobar",
        -- For component params only.
        -- When true, will default to the value in the task's default_component_params
        default_from_task = true,
      }
    }
<

The following types are available:

>lua
    {
      type = "string"
    }
    {
      type = "boolean"
    }
    {
      type = "number"
    }
    {
      type = "integer"
    }
    {
      type = "list",
      subtype = {
        type = "string"
      },
      delimiter = ",",
    }
    {
      type = "enum",
      choices = {"ONE", "TWO", "THREE"},
    }
    {
      -- This is used when the value is too complex to be represented or edited by the user in the task editor.
      -- It should generally only be used by components (which are usually configured programmatically)
      -- and not templates (which usually prompt the user for their parameters)
      type = "opaque"
    }
<

Templates can define params to be a function, to dynamically generate the
params.

>lua
    require("overseer").register_template({
      name = "Git checkout",
      params = function()
        local stdout = vim.system({ "git", "branch", "--format=%(refname:short)" }):wait().stdout
        local branches = vim.split(stdout, "\n", { trimempty = true })
        return {
          branch = {
            desc = "Branch to checkout",
            type = "enum",
            choices = branches,
          },
        }
      end,
      builder = function(params)
        return {
          cmd = { "git", "checkout", params.branch },
        }
      end,
    })
<

--------------------------------------------------------------------------------
ACTIONS                                                         *overseer-actions*

Actions can be performed on tasks by using the `keymap.run_action` keybinding in
the task list, or
by the `OverseerTaskAction` command. Actions are simply custom functions that
will do something to
or with a task.

Browse the set of built-in actions at lua/overseer/task_list/actions.lua.

You can define your own or disable any of the built-in actions in the call to
setup():

>lua
    overseer.setup({
      actions = {
        ["My custom action"] = {
          desc = "This is an optional description. It may be omitted.",
          -- Optional function that will determine when this action is available
          condition = function(task)
            if task.name == "foobar" then
              return true
            else
              return false
            end
          end,
          run = function(task)
            -- Your custom logic here
          end,
        },
    
        -- Disable built-in actions by setting them to 'false'
        watch = false,
      },
      -- You can optionally add keymaps to run your action in the task list
      -- It will always be available in the "RunAction" menu, but it may be
      -- worth mapping it directly if you use it often.
      task_list = {
        keymaps = {
          ["P"] = { "keymap.run_action", opts = { action = "my action" }, desc = "Do something cool" },
        },
      },
    })
<

================================================================================
vim:tw=80:ts=2:ft=help:norl:syntax=help:
