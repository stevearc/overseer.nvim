*overseer.txt*
*Overseer* *overseer* *overseer.nvim*
--------------------------------------------------------------------------------
CONTENTS                                                       *overseer-contents*

  1. Commands                                              |overseer-commands|
  2. Options                                                |overseer-options|
  3. Highlights                                          |overseer-highlights|
  4. Api                                                        |overseer-api|
  5. Components                                          |overseer-components|
  6. Strategies                                          |overseer-strategies|
  7. Parsers                                                |overseer-parsers|
  8. Parameters                                              |overseer-params|
  9. Actions                                                |overseer-actions|

--------------------------------------------------------------------------------
COMMANDS                                                       *overseer-commands*

OverseerOpen[!] `left/right/bottom`                                  *:OverseerOpen*
    Open the overseer window. With `!` cursor stays in current window

OverseerClose                                                     *:OverseerClose*
    Close the overseer window

OverseerToggle[!] `left/right/bottom`                              *:OverseerToggle*
    Toggle the overseer window. With `!` cursor stays in current window

OverseerSaveBundle `[name]`                                    *:OverseerSaveBundle*
    Serialize and save the current tasks to disk

OverseerLoadBundle[!] `[name]`                                 *:OverseerLoadBundle*
    Load tasks that were saved to disk. With `!` tasks will not be started

OverseerDeleteBundle `[name]`                                *:OverseerDeleteBundle*
    Delete a saved task bundle

OverseerRunCmd `[command]`                                         *:OverseerRunCmd*
    Run a raw shell command

OverseerRun `[name/tags]`                                             *:OverseerRun*
    Run a task from a template

OverseerInfo                                                       *:OverseerInfo*
    Display diagnostic information about overseer

OverseerBuild                                                     *:OverseerBuild*
    Open the task builder

OverseerQuickAction `[action]`                                *:OverseerQuickAction*
    Run an action on the most recent task, or the task under the cursor

OverseerTaskAction                                           *:OverseerTaskAction*
    Select a task to run an action on

OverseerClearCache                                           *:OverseerClearCache*
    Clear the task cache

--------------------------------------------------------------------------------
OPTIONS                                                         *overseer-options*

>lua
    require("overseer").setup({
      -- Default task strategy
      strategy = "terminal",
      -- Template modules to load
      templates = { "builtin" },
      -- When true, tries to detect a green color from your colorscheme to use for success highlight
      auto_detect_success_color = true,
      -- Patch nvim-dap to support preLaunchTask and postDebugTask
      dap = true,
      -- Configure the task list
      task_list = {
        -- Default detail level for tasks. Can be 1-3.
        default_detail = 1,
        -- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_width and max_width can be a single value or a list of mixed integer/float types.
        -- max_width = {100, 0.2} means "the lesser of 100 columns or 20% of total"
        max_width = { 100, 0.2 },
        -- min_width = {40, 0.1} means "the greater of 40 columns or 10% of total"
        min_width = { 40, 0.1 },
        -- optionally define an integer/float for the exact width of the task list
        width = nil,
        max_height = { 20, 0.1 },
        min_height = 8,
        height = nil,
        -- String that separates tasks
        separator = "────────────────────────────────────────",
        -- Default direction. Can be "left", "right", or "bottom"
        direction = "left",
        -- Set keymap to false to remove default behavior
        -- You can add custom keymaps here as well (anything vim.keymap.set accepts)
        bindings = {
          ["?"] = "ShowHelp",
          ["g?"] = "ShowHelp",
          ["<CR>"] = "RunAction",
          ["<C-e>"] = "Edit",
          ["o"] = "Open",
          ["<C-v>"] = "OpenVsplit",
          ["<C-s>"] = "OpenSplit",
          ["<C-f>"] = "OpenFloat",
          ["<C-q>"] = "OpenQuickFix",
          ["p"] = "TogglePreview",
          ["<C-l>"] = "IncreaseDetail",
          ["<C-h>"] = "DecreaseDetail",
          ["L"] = "IncreaseAllDetail",
          ["H"] = "DecreaseAllDetail",
          ["["] = "DecreaseWidth",
          ["]"] = "IncreaseWidth",
          ["{"] = "PrevTask",
          ["}"] = "NextTask",
          ["<C-k>"] = "ScrollOutputUp",
          ["<C-j>"] = "ScrollOutputDown",
          ["q"] = "Close",
        },
      },
      -- See :help overseer-actions
      actions = {},
      -- Configure the floating window used for task templates that require input
      -- and the floating window used for editing tasks
      form = {
        border = "rounded",
        zindex = 40,
        -- Dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_X and max_X can be a single value or a list of mixed integer/float types.
        min_width = 80,
        max_width = 0.9,
        width = nil,
        min_height = 10,
        max_height = 0.9,
        height = nil,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {
          winblend = 10,
        },
      },
      task_launcher = {
        -- Set keymap to false to remove default behavior
        -- You can add custom keymaps here as well (anything vim.keymap.set accepts)
        bindings = {
          i = {
            ["<C-s>"] = "Submit",
            ["<C-c>"] = "Cancel",
          },
          n = {
            ["<CR>"] = "Submit",
            ["<C-s>"] = "Submit",
            ["q"] = "Cancel",
            ["?"] = "ShowHelp",
          },
        },
      },
      task_editor = {
        -- Set keymap to false to remove default behavior
        -- You can add custom keymaps here as well (anything vim.keymap.set accepts)
        bindings = {
          i = {
            ["<CR>"] = "NextOrSubmit",
            ["<C-s>"] = "Submit",
            ["<Tab>"] = "Next",
            ["<S-Tab>"] = "Prev",
            ["<C-c>"] = "Cancel",
          },
          n = {
            ["<CR>"] = "NextOrSubmit",
            ["<C-s>"] = "Submit",
            ["<Tab>"] = "Next",
            ["<S-Tab>"] = "Prev",
            ["q"] = "Cancel",
            ["?"] = "ShowHelp",
          },
        },
      },
      -- Configure the floating window used for confirmation prompts
      confirm = {
        border = "rounded",
        zindex = 40,
        -- Dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_X and max_X can be a single value or a list of mixed integer/float types.
        min_width = 20,
        max_width = 0.5,
        width = nil,
        min_height = 6,
        max_height = 0.9,
        height = nil,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {
          winblend = 10,
        },
      },
      -- Configuration for task floating windows
      task_win = {
        -- How much space to leave around the floating window
        padding = 2,
        border = "rounded",
        -- Set any window options here (e.g. winhighlight)
        win_opts = {
          winblend = 10,
        },
      },
      -- Configuration for mapping help floating windows
      help_win = {
        border = "rounded",
        win_opts = {},
      },
      -- Aliases for bundles of components. Redefine the builtins, or create your own.
      component_aliases = {
        -- Most tasks are initialized with the default components
        default = {
          { "display_duration", detail_level = 2 },
          "on_output_summarize",
          "on_exit_set_status",
          "on_complete_notify",
          "on_complete_dispose",
        },
        -- Tasks from tasks.json use these components
        default_vscode = {
          "default",
          "on_result_diagnostics",
          "on_result_diagnostics_quickfix",
        },
      },
      bundles = {
        -- When saving a bundle with OverseerSaveBundle or save_task_bundle(), filter the tasks with
        -- these options (passed to list_tasks())
        save_task_opts = {
          bundleable = true,
        },
      },
      -- A list of components to preload on setup.
      -- Only matters if you want them to show up in the task editor.
      preload_components = {},
      -- Controls when the parameter prompt is shown when running a template
      --   always    Show when template has any params
      --   missing   Show when template has any params not explicitly passed in
      --   allow     Only show when a required param is missing
      --   avoid     Only show when a required param with no default value is missing
      --   never     Never show prompt (error if required param missing)
      default_template_prompt = "allow",
      -- For template providers, how long to wait (in ms) before timing out.
      -- Set to 0 to disable timeouts.
      template_timeout = 3000,
      -- Cache template provider results if the provider takes longer than this to run.
      -- Time is in ms. Set to 0 to disable caching.
      template_cache_threshold = 100,
      -- Configure where the logs go and what level to use
      -- Types are "echo", "notify", and "file"
      log = {
        {
          type = "echo",
          level = vim.log.levels.WARN,
        },
        {
          type = "file",
          filename = "overseer.log",
          level = vim.log.levels.WARN,
        },
      },
    })
<

--------------------------------------------------------------------------------
HIGHLIGHTS                                                   *overseer-highlights*

OverseerPENDING                                               *hl-OverseerPENDING*
    Pending tasks

OverseerRUNNING                                               *hl-OverseerRUNNING*
    Running tasks

OverseerSUCCESS                                               *hl-OverseerSUCCESS*
    Succeeded tasks

OverseerCANCELED                                             *hl-OverseerCANCELED*
    Canceled tasks

OverseerFAILURE                                               *hl-OverseerFAILURE*
    Failed tasks

OverseerTask                                                     *hl-OverseerTask*
    Used to render the name of a task or template

OverseerTaskBorder                                         *hl-OverseerTaskBorder*
    The separator in the task list

OverseerOutput                                                 *hl-OverseerOutput*
    The output summary in the task list

OverseerComponent                                           *hl-OverseerComponent*
    The name of a component in the task list or task editor

OverseerField                                                   *hl-OverseerField*
    The name of a field in the task or template editor

--------------------------------------------------------------------------------
API                                                                 *overseer-api*

setup({opts})                                                     *overseer.setup*
    Initialize overseer

    Parameters:
      {opts} `overseer.Config|nil` Configuration options

on_setup({callback})                                           *overseer.on_setup*
    Add a callback to run after overseer lazy setup

    Parameters:
      {callback} `fun()`

new_task({opts}): overseer.Task                                *overseer.new_task*
    Create a new Task

    Parameters:
      {opts} `overseer.TaskDefinition`
          {cmd}        `string|string[]` Command to run. If it's a string it is
                       run in the shell; a table is run directly
          {args}       `nil|string[]` Arguments to pass to the command
          {name}       `nil|string` Name of the task. Defaults to the cmd
          {cwd}        `nil|string` Working directory to run in
          {env}        `nil|table<string, string>` Additional environment
                       variables
          {strategy}   `nil|overseer.Serialized` Definition for a run Strategy
          {metadata}   `nil|table` Arbitrary metadata for your own use
          {default_component_params} `nil|table` Default values for component
                       params
          {components} `nil|overseer.Serialized[]` List of components to attach.
                       Defaults to `{"default"}`

    Examples: >lua
      local task = overseer.new_task({
        cmd = {'./build.sh'},
        args = {'all'},
        components = {{'on_output_quickfix', open=true}, 'default'}
      })
      task:start()
<

toggle({opts})                                                   *overseer.toggle*
    Open or close the task list

    Parameters:
      {opts} `overseer.WindowOpts|nil`
          {enter}     `boolean|nil` If false, stay in current window. Default
                      true
          {direction} `nil|"left"|"right"` Which direction to open the task list

open({opts})                                                       *overseer.open*
    Open the task list

    Parameters:
      {opts} `overseer.WindowOpts|nil`
          {enter}     `boolean|nil` If false, stay in current window. Default
                      true
          {direction} `nil|"left"|"right"` Which direction to open the task list

close()                                                           *overseer.close*
    Close the task list


list_task_bundles(): string[]                         *overseer.list_task_bundles*
    Get the list of saved task bundles

    Returns:
      `string[]` Names of task bundles

load_task_bundle({name}, {opts})                       *overseer.load_task_bundle*
    Load tasks from a saved bundle

    Parameters:
      {name} `nil|string`
      {opts} `nil|table`
          {ignore_missing} `nil|boolean` When true, don't notify if bundle
                           doesn't exist
          {autostart}      `nil|boolean` When true, start the tasks after
                           loading (default true)

save_task_bundle({name}, {tasks}, {opts})              *overseer.save_task_bundle*
    Save tasks to a bundle on disk

    Parameters:
      {name}  `string|nil` Name of bundle. If nil, will prompt user.
      {tasks} `nil|overseer.Task[]` Specific tasks to save. If nil, uses
              config.bundles.save_task_opts
      {opts}  `table|nil`
          {on_conflict} `nil|"overwrite"|"append"|"cancel"`

delete_task_bundle({name})                           *overseer.delete_task_bundle*
    Delete a saved task bundle

    Parameters:
      {name} `string|nil`

list_tasks({opts}): overseer.Task[]                          *overseer.list_tasks*
    List all tasks

    Parameters:
      {opts} `overseer.ListTaskOpts|nil`
          {unique}       `boolean|nil` Deduplicates non-running tasks by name
          {name}         `nil|string|string[]` Only list tasks with this name or
                         names
          {name_not}     `nil|boolean` Invert the name search (tasks *without*
                         that name)
          {status}       `nil|overseer.Status|overseer.Status[]` Only list tasks
                         with this status or statuses
          {status_not}   `nil|boolean` Invert the status search
          {recent_first} `nil|boolean` The most recent tasks are first in the
                         list
          {bundleable}   `nil|boolean` Only list tasks that should be included
                         in a bundle
          {filter}       `nil|fun(task: overseer.Task): boolean`

run_template({opts}, {callback})                           *overseer.run_template*
    Run a task from a template

    Parameters:
      {opts}     `overseer.TemplateRunOpts`
          {name}      `nil|string` The name of the template to run
          {tags}      `nil|string[]` List of tags used to filter when searching
                      for template
          {autostart} `nil|boolean` When true, start the task after creating it
                      (default true)
          {first}     `nil|boolean` When true, take first result and never show
                      the task picker. Default behavior will auto-set this based
                      on presence of name and tags
          {prompt}    `nil|"always"|"missing"|"allow"|"avoid"|"never"` Controls
                      when to prompt user for parameter input
          {params}    `nil|table` Parameters to pass to template
          {cwd}       `nil|string` Working directory for the task
          {env}       `nil|table<string, string>` Additional environment
                      variables for the task
      {callback} `nil|fun(task: overseer.Task|nil, err: string|nil)`

    Note:
      The prompt option will control when the user is presented a popup dialog to input template
      parameters. The possible values are:
         always    Show when template has any params
         missing   Show when template has any params not explicitly passed in
         allow     Only show when a required param is missing
         avoid     Only show when a required param with no default value is missing
         never     Never show prompt (error if required param missing)
      The default is controlled by the default_template_prompt config option.

    Examples: >lua
      -- Run the task named "make all"
      -- equivalent to :OverseerRun make all
      overseer.run_template({name = "make all"})
      -- Run the default "build" task
      -- equivalent to :OverseerRun BUILD
      overseer.run_template({tags = {overseer.TAG.BUILD}})
      -- Run the task named "serve" with some default parameters
      overseer.run_template({name = "serve", params = {port = 8080}})
      -- Create a task but do not start it
      overseer.run_template({name = "make", autostart = false}, function(task)
        -- do something with the task
      end)
      -- Run a task and immediately open the floating window
      overseer.run_template({name = "make"}, function(task)
        if task then
          overseer.run_action(task, 'open float')
        end
      end)
      -- Run a task and always show the parameter prompt
      overseer.run_template({name = "npm watch", prompt = "always"})
<

preload_task_cache({opts}, {cb})                     *overseer.preload_task_cache*
    Preload templates for run_template

    Parameters:
      {opts} `nil|table`
          {dir} `string`
          {ft}  `nil|string`
      {cb}   `nil|fun()` Called when preloading is complete

    Note:
      Typically this would be done to prevent a long wait time for :OverseerRun when using a slow
      template provider.

    Examples: >lua
      -- Automatically preload templates for the current directory
      vim.api.nvim_create_autocmd({"VimEnter", "DirChanged"}, {
        local cwd = vim.v.cwd or vim.fn.getcwd()
        require("overseer").preload_task_cache({ dir = cwd })
      })
<

clear_task_cache({opts})                               *overseer.clear_task_cache*
    Clear cached templates for run_template

    Parameters:
      {opts} `nil|table`
          {dir} `string`
          {ft}  `nil|string`

run_action({task}, {name})                                   *overseer.run_action*
    Run an action on a task

    Parameters:
      {task} `overseer.Task`
      {name} `string|nil` Name of action. When omitted, prompt user to pick.

wrap_template({base}, {override}, {default_params}): overseer.TemplateFileDefinition *overseer.wrap_template*
    Create a new template by overriding fields on another

    Parameters:
      {base}           `overseer.TemplateFileDefinition` The base template
                       definition to wrap
      {override}       `nil|table<string, any>` Override any fields on the base
      {default_params} `nil|table<string, any>` Provide default values for any
                       parameters on the base

    Note:
      This is typically used for a TemplateProvider, to define the task a single time and generate
      multiple templates based on the available args.

    Examples: >lua
      local tmpl = {
        params = {
          args = { type = 'list', delimiter = ' ' }
        },
        builder = function(params)
        return {
          cmd = { 'make' },
          args = params.args,
        }
      }
      local template_provider = {
        generator = function(opts, cb)
          cb({
            overseer.wrap_template(tmpl, nil, { args = { 'all' } }),
            overseer.wrap_template(tmpl, {name = 'make clean'}, { args = { 'clean' } }),
          })
        end
      }
<

add_template_hook({opts}, {hook})                     *overseer.add_template_hook*
    Add a hook that runs on a TaskDefinition before the task is created

    Parameters:
      {opts} `nil|overseer.HookOptions` When nil, run the hook on all templates
          {name}     `nil|string` Only run if the template name matches this
                     pattern (using string.match)
          {module}   `nil|string` Only run if the template module matches this
                     pattern (using string.match)
          {filetype} `nil|string|string[]` Only run if the current file is one
                     of these filetypes
          {dir}      `nil|string|string[]` Only run if inside one of these
                     directories
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      -- Add on_output_quickfix component to all "cargo" templates
      overseer.add_template_hook({ module = "^cargo$" }, function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end)
      -- Remove the on_complete_notify component from "cargo clean" task
      overseer.add_template_hook({ name = "cargo clean" }, function(task_defn, util)
        util.remove_component(task_defn, "on_complete_notify")
      end)
      -- Add an environment variable for all go tasks in a specific dir
      overseer.add_template_hook({ name = "^go .*", dir = "/path/to/project" }, function(task_defn, util)
        task_defn.env = vim.tbl_extend('force', task_defn.env or {}, {
          GO111MODULE = "on"
        })
      end)
<

remove_template_hook({opts}, {hook})               *overseer.remove_template_hook*
    Remove a hook that was added with add_template_hook

    Parameters:
      {opts} `nil|overseer.HookOptions` Same as for add_template_hook
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      local opts = {module = "cargo"}
      local hook = function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end
      overseer.add_template_hook(opts, hook)
      -- Remove should pass in the same opts as add
      overseer.remove_template_hook(opts, hook)
<

register_template({defn})                             *overseer.register_template*
    Directly register an overseer template

    Parameters:
      {defn} `overseer.TemplateDefinition|overseer.TemplateProvider`

load_template({name})                                     *overseer.load_template*
    Load a template definition from its module location

    Parameters:
      {name} `string`

    Examples: >lua
      -- This will load the template in lua/overseer/template/mytask.lua
      overseer.load_template('mytask')
<

debug_parser()                                             *overseer.debug_parser*
    Open a tab with windows laid out for debugging a parser

--------------------------------------------------------------------------------
COMPONENTS                                                   *overseer-components*

dependencies                                                        *dependencies*
    Set dependencies for task

    Parameters:
      {*task_names} `list[string]` Names of dependency task templates This can
                    be a list of strings (template names, e.g. {"cargo build"}),
                    tables (name with params, e.g. {"shell", cmd = "sleep 10"}),
                    or tables (raw task params, e.g. {cmd = "sleep 10"})
      {sequential}  `boolean` (default `false`)

display_duration                                                *display_duration*
    Display the run duration

    Parameters:
      {detail_level} `integer` Show the duration at this detail level (default
                     `1`)

on_complete_dispose                                          *on_complete_dispose*
    After task is completed, dispose it after a timeout

    Parameters:
      {statuses} `list[enum]` Tasks with one of these statuses will be disposed
                 (default `["SUCCESS", "FAILURE", "CANCELED"]`)
      {timeout}  `number` Time to wait (in seconds) before disposing (default
                 `300`)

on_complete_notify                                            *on_complete_notify*
    vim.notify when task is completed

    Parameters:
      {on_change} `boolean` Only notify when task status changes from previous
                  value (default `false`) This is mostly used when a task is
                  going to be restarted, and you want notifications only when it
                  goes from SUCCESS to FAILURE, or vice-versa
      {statuses}  `list[enum]` List of statuses to notify on (default
                  `["FAILURE", "SUCCESS"]`)
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

on_complete_restart                                          *on_complete_restart*
    Restart task when it completes

    Parameters:
      {delay}    `number` How long to wait (in ms) post-result before triggering
                 restart (default `500`)
      {statuses} `list[enum]` What statuses will trigger a restart (default
                 `["FAILURE"]`)

on_exit_set_status                                            *on_exit_set_status*
    Sets final task status based on exit code

    Parameters:
      {success_codes} `list[integer]` Additional exit codes to consider as
                      success

on_output_parse                                                  *on_output_parse*
    Parses task output and sets task result

    Parameters:
      {parser}          `opaque` Parser definition to extract values from output
      {problem_matcher} `opaque` VS Code-style problem matcher
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)
      {precalculated_vars} `opaque` Precalculated VS Code task variables Tasks
                        that are started from the VS Code provider precalculate
                        certain interpolated variables (e.g.
                        ${workspaceFolder}). We pass those in as params so they
                        will remain stable even if Neovim's state changes in
                        between creating and running (or restarting) the task.

on_output_quickfix                                            *on_output_quickfix*
    Set all task output into the quickfix (on complete)

    Parameters:
      {close}           `boolean` Close the quickfix on completion if no
                        errorformat matches (default `false`)
      {errorformat}     `string` See :help errorformat
      {items_only}      `boolean` Only show lines that match the errorformat
                        (default `false`)
      {open}            `boolean` Open the quickfix on output (default `false`)
      {open_height}     `integer` The height of the quickfix when opened
      {open_on_exit}    `enum` Open the quickfix when the command exits (default
                        `"never"`) (choices: `"never"|"failure"|"always"`)
      {open_on_match}   `boolean` Open the quickfix when the errorformat finds a
                        match (default `false`)
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)
      {set_diagnostics} `boolean` Add the matching items to vim.diagnostics
                        (default `false`)
      {tail}            `boolean` Update the quickfix with task output as it
                        happens, instead of waiting until completion (default
                        `true`) This may cause unexpected results for commands
                        that produce "fancy" output using terminal escape codes
                        (e.g. animated progress indicators)

on_output_summarize                                          *on_output_summarize*
    Summarize task output in the task list

    Parameters:
      {max_lines} `integer` Number of lines of output to show when detail > 1
                  (default `4`)

on_output_write_file                                        *on_output_write_file*
    Write task output to a file

    Parameters:
      {*filename} `string` Name of file to write output to

on_result_diagnostics                                      *on_result_diagnostics*
    If task result contains diagnostics, display them

    Parameters:
      {remove_on_restart} `boolean` Remove diagnostics when task restarts
      {signs}        `boolean` Override the default diagnostics.signs setting
      {underline}    `boolean` Override the default diagnostics.underline
                     setting
      {virtual_text} `boolean` Override the default diagnostics.virtual_text
                     setting

on_result_diagnostics_quickfix                    *on_result_diagnostics_quickfix*
    If task result contains diagnostics, add them to the quickfix

    Parameters:
      {close}       `boolean` If true, close the quickfix when there are no
                    diagnostics (default `false`)
      {open}        `boolean` If true, open the quickfix when there are
                    diagnostics (default `false`)
      {set_empty_results} `boolean` If true, overwrite the current quickfix even
                    if there are no diagnostics (default `false`)
      {use_loclist} `boolean` If true, use the loclist instead of quickfix
                    (default `false`)

on_result_notify                                                *on_result_notify*
    vim.notify when task receives results
    Normally you will want to use on_complete_notify. If you have a long-running
    watch task (e.g. `tsc --watch`) that produces new results periodically, then
    this is the component you want.

    Parameters:
      {infer_status_from_diagnostics} `boolean` Notification level will be
                  error/info depending on if diagnostics are present (default
                  `true`)
      {on_change} `boolean` Only notify when status changes from previous value
                  (default `true`) This only works when
                  infer_status_from_diagnostics = true
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

restart_on_save                                                  *restart_on_save*
    Restart on any buffer :write

    Parameters:
      {delay}     `number` How long to wait (in ms) before triggering restart
                  (default `500`)
      {interrupt} `boolean` Interrupt running tasks (default `true`)
      {mode}      `enum` How to watch the paths (default `"autocmd"`) 'autocmd'
                  will set autocmds on BufWritePost. 'uv' will use a libuv file
                  watcher (recursive watching may not be supported on all
                  platforms). (choices: `"autocmd"|"uv"`)
      {paths}     `list[string]` Only restart when writing files in these paths
                  (can be directory or file)

run_after                                                              *run_after*
    Run other tasks after this task completes

    Parameters:
      {*task_names} `list[string]` Names of dependency task templates This can
                    be a list of strings (template names, e.g. {"cargo build"}),
                    tables (name with params, e.g. {"shell", cmd = "sleep 10"}),
                    or tables (raw task params, e.g. {cmd = "sleep 10"})
      {detach}      `boolean` Tasks created will not be linked to the parent
                    task (default `false`) This means they will not restart when
                    the parent restarts, and will not be disposed when the
                    parent is disposed
      {statuses}    `list[enum]` Only run successive tasks if the final status
                    is in this list (default `["SUCCESS"]`)

timeout                                                                  *timeout*
    Cancel task if it exceeds a timeout

    Parameters:
      {timeout} `integer` Time to wait (in seconds) before canceling (default
                `120`)

unique                                                                    *unique*
    Ensure that this task does not have any duplicates

    Parameters:
      {replace} `boolean` If a prior task exists, replace it. When false, will
                restart the existing task and dispose the current task (default
                `true`) Note that when this is false a new task that is created
                will restart the existing one and _dispose itself_. This can
                lead to unexpected behavior if you are creating a task and then
                trying to use that reference (to run actions on it, use it as a
                dependency, etc)
      {restart_interrupts} `boolean` When replace = false, should restarting the
                existing task interrupt it (default `true`)

--------------------------------------------------------------------------------
STRATEGIES                                                   *overseer-strategies*

jobstart({opts}): overseer.Strategy                            *strategy.jobstart*
    Run tasks using jobstart()

    Parameters:
      {opts} `nil|table`
          {preserve_output} `boolean` If true, don't clear the buffer when tasks
                            restart
          {use_terminal}    `boolean` If false, use a normal non-terminal buffer
                            to store the output. This may produce unwanted
                            results if the task outputs terminal escape
                            sequences.

orchestrator({opts}): overseer.Strategy                    *strategy.orchestrator*
    Strategy for a meta-task that manage a sequence of other tasks

    Parameters:
      {opts} `table`
          {tasks} `table` A list of task definitions to run. Can include sub-
                  lists that will be run in parallel

    Examples: >lua
      overseer.new_task({
        name = "Build and serve app",
        strategy = {
          "orchestrator",
          tasks = {
            "make clean", -- Step 1: clean
            {             -- Step 2: build js and css in parallel
               "npm build",
              { "shell", cmd = "lessc styles.less styles.css" },
            },
            "npm serve",  -- Step 3: serve
          },
        },
      })
<

terminal(): overseer.Strategy                                  *strategy.terminal*
    Run tasks using termopen()


test(): overseer.Strategy                                          *strategy.test*
    Strategy used for unit testing


toggleterm({opts}): overseer.Strategy                        *strategy.toggleterm*
    Run tasks using the toggleterm plugin

    Parameters:
      {opts} `nil|table`
          {use_shell}     `nil|boolean` load user shell before running task
          {direction}     `nil|"vertical"|"horizontal"|"tab"|"float"`
          {highlights}    `nil|table` map to a highlight group name and a table
                          of it's values
          {auto_scroll}   `nil|boolean` automatically scroll to the bottom on
                          task output
          {close_on_exit} `nil|boolean` close the terminal and delete terminal
                          buffer (if open) after task exits
          {quit_on_exit}  `"never"|"always"|"success"` close the terminal window
                          (if open) after task exits
          {open_on_start} `nil|boolean` toggle open the terminal automatically
                          when task starts
          {hidden}        `nil|boolean` cannot be toggled with normal ToggleTerm
                          commands
          {on_create}     `nil|fun(term: table)` function to execute on terminal
                          creation

--------------------------------------------------------------------------------
PARSERS                                                         *overseer-parsers*

always                                                             *parser.always*
    A decorator that always returns SUCCESS

    Parameters:
      {succeed} `boolean` Set to false to always return FAILURE (default true)
      {child}   `parser` The child parser node

    Examples:
    An extract node that returns SUCCESS even when it fails
>
    {"always",
      {"extract", "^([^%s].+):(%d+): (.+)$", "filename", "lnum", "text" }
    }
<

append                                                             *parser.append*
    Append the current item to the results list

    Parameters:
      {opts} `object` Configuration options
          {postprocess} `function` Call this function to do post-extraction
                        processing on the values

dispatch                                                         *parser.dispatch*
    Dispatch an event

    Parameters:
      {name} `string` Event name
      {arg}  `any|fun()` A value to send with the event, or a function that
             creates a value

    Examples:
    clear_results will clear all current results from the parser. Pass `true` to
    only clear the results under the current key
>
    {"dispatch", "clear_results"}
<

    Examples:
    set_results is used by the on_output_parse component to immediately set the
    current results on the task
>
    {"dispatch", "set_results"}
<

ensure                                                             *parser.ensure*
    Decorator that runs a child until it succeeds

    Parameters:
      {succeed} `boolean` Set to false to run child until failure (default true)
      {child}   `parser` The child parser node

    Examples:
    An extract node that runs until it successfully parses
>
    {"ensure",
      {"extract", "^([^%s].+):(%d+): (.+)$", "filename", "lnum", "text" }
    }
<

extract                                                           *parser.extract*
    Parse a line into an object and append it to the results

    Parameters:
      {opts}    `object` Configuration options
          {consume}     `boolean` Consumes the line of input, blocking execution
                        until the next line is fed in (default true)
          {append}      `boolean` After parsing, append the item to the results
                        list. When false, the pending item will stick around.
                        (default true)
          {regex}       `boolean` Use vim regex instead of lua pattern (see
                        :help pattern) (default false)
          {postprocess} `function` Call this function to do post-extraction
                        processing on the values
      {pattern} `string|function|string[]` The lua pattern to use for matching.
                Must have the same number of capture groups as there are field
                arguments.
      {field}   `string` The name of the extracted capture group. Use `"_"` to
                discard.

    Examples:
    Convert a line in the format of `/path/to/file.txt:123: This is a message`
    into an item `{filename = "/path/to/file.txt", lnum = 123, text = "This is a
    message"}`
>
    {"extract", "^([^%s].+):(%d+): (.+)$", "filename", "lnum", "text" }
<

    Examples:
    The same logic, but using a vim regex
>
    {"extract", {regex = true}, "\\v^([^:space:].+):(\\d+): (.+)$", "filename", "lnum", "text" }
<

extract_efm                                                   *parser.extract_efm*
    Parse a line using vim's errorformat and append it to the results

    Parameters:
      {opts} `object` Configuration options
          {efm}         `string` The errorformat string to use. Defaults to
                        current option value.
          {consume}     `boolean` Consumes the line of input, blocking execution
                        until the next line is fed in (default true)
          {append}      `boolean` After parsing, append the item to the results
                        list. When false, the pending item will stick around.
                        (default true)
          {test}        `function` A function that operates on the parsed value
                        and returns true/false for SUCCESS/FAILURE
          {postprocess} `function` Call this function to do post-extraction
                        processing on the values

extract_json                                                 *parser.extract_json*
    Parse a line as json and append it to the results

    Parameters:
      {opts} `object` Configuration options
          {consume}     `boolean` Consumes the line of input, blocking execution
                        until the next line is fed in (default true)
          {append}      `boolean` After parsing, append the item to the results
                        list. When false, the pending item will stick around.
                        (default true)
          {test}        `function` A function that operates on the parsed value
                        and returns true/false for SUCCESS/FAILURE
          {postprocess} `function` Call this function to do post-extraction
                        processing on the values

extract_multiline                                       *parser.extract_multiline*
    Extract a multiline string as a single field on an item

    Parameters:
      {opts}    `object` Configuration options
          {append} `boolean` After parsing, append the item to the results list.
                   When false, the pending item will stick around. (default
                   true)
      {pattern} `string|function` The lua pattern to use for matching. As long
                as the pattern matches, lines will continue to be appended to
                the field.
      {field}   `string` The name of the field to add to the item

    Examples:
    Extract all indented lines as a message
>
    {"extract_multiline", "^(    .+)", "message"}
<

extract_nested                                             *parser.extract_nested*
    Run a subparser and put the extracted results on the field of an item

    Parameters:
      {opts}  `object` Configuration options
          {append}        `boolean` After parsing, append the item to the
                          results list. When false, the pending item will stick
                          around. (default true)
          {fail_on_empty} `boolean` Return FAILURE if there are no results from
                          the child (default true)
      {field} `string` The name of the field to add to the item
      {child} `parser` The child parser node

    Examples:
    Extract a golang test failure, then add the stacktrace to it (if present)
>
    {"extract",
      {
        regex = true,
        append = false,
      },
      "\\v^--- (FAIL|PASS|SKIP): ([^[:space:] ]+) \\(([0-9\\.]+)s\\)",
      "status",
      "name",
      "duration",
    },
    {"always",
      {"sequence",
        {"test", "^panic:"},
        {"skip_until", "^goroutine%s"},
        {"extract_nested",
          { append = false },
          "stacktrace",
          {"loop",
            {"sequence",
              {"extract",{ append = false }, { "^(.+)%(.*%)$", "^created by (.+)$" }, "text"},
              {"extract","^%s+([^:]+.go):([0-9]+)", "filename", "lnum"}
            }
          }
        }
      }
    }
<

invert                                                             *parser.invert*
    A decorator that inverts the child's return value

    Parameters:
      {child} `parser` The child parser node

    Examples:
    An extract node that returns SUCCESS when it fails, and vice-versa
>
    {"invert",
      {"extract", "^([^%s].+):(%d+): (.+)$", "filename", "lnum", "text" }
    }
<

loop                                                                 *parser.loop*
    A decorator that repeats the child

    Parameters:
      {opts}  `object` Configuration options
          {ignore_failure} `boolean` Keep looping even when the child fails
                           (default false)
          {repetitions}    `integer` When set, loop a set number of times then
                           return SUCCESS
      {child} `parser` The child parser node

parallel                                                         *parser.parallel*
    Run the child nodes in parallel

    Parameters:
      {opts}  `object` Configuration options
          {break_on_first_failure} `boolean` Stop executing as soon as a child
                           returns FAILURE (default true)
          {break_on_first_success} `boolean` Stop executing as soon as a child
                           returns SUCCESS (default false)
          {reset_children} `boolean` Reset all children at the beginning of each
                           iteration (default false)
      {child} `parser` The child parser nodes. Can be passed in as varargs or as
              a list.

sequence                                                         *parser.sequence*
    Run the child nodes sequentially

    Parameters:
      {opts}  `object` Configuration options
          {break_on_first_failure} `boolean` Stop executing as soon as a child
                     returns FAILURE (default true)
          {break_on_first_success} `boolean` Stop executing as soon as a child
                     returns SUCCESS (default false)
      {child} `parser` The child parser nodes. Can be passed in as varargs or as
              a list.

    Examples:
    Extract the message text from one line, then the filename and lnum from the
    next line
>
    {"sequence",
      {"extract", { append = false }, { "^(.+)%(.*%)$", "^created by (.+)$" }, "text"},
      {"extract", "^%s+([^:]+.go):([0-9]+)", "filename", "lnum"}
    }
<

set_defaults                                                 *parser.set_defaults*
    A decorator that adds values to any items extracted by the child

    Parameters:
      {opts}  `object` Configuration options
          {values}     `object` Hardcoded key-value pairs to set as default
                       values
          {hoist_item} `boolean` Take the current pending item, and use its
                       fields as the default key-value pairs (default true)
      {child} `parser` The child parser node

    Examples:
    Extract the filename from a header line, then for each line of output
    beneath it parse the test name + status, and also add the filename to each
    item
>
    {"sequence",
      {"extract", {append = false}, "^Test result (.+)$", "filename"}
      {"set_defaults",
        {"loop",
          {"extract", "^Test (.+): (.+)$", "test_name", "status"}
        }
      }
    }
<

skip_lines                                                     *parser.skip_lines*
    Skip over a set number of lines

    Parameters:
      {count} `integer` How many lines to skip

skip_until                                                     *parser.skip_until*
    Skip over lines until one matches

    Parameters:
      {opts}    `object` Configuration options
          {skip_matching_line} `boolean` Consumes the line that matches. Later
                  nodes will only see the next line. (default true)
          {regex} `boolean` Use vim regex instead of lua pattern (see :help
                  pattern) (default true)
      {pattern} `string|string[]|fun(line: string): string` The lua pattern to
                use for matching. The node succeeds if any of these patterns
                match.

    Examples:
    Skip input until we see "Error" or "Warning"
>
    {"skip_until", "^Error:", "^Warning:"}
<

test                                                                 *parser.test*
    Returns SUCCESS when the line matches the pattern

    Parameters:
      {opts}    `object` Configuration options
          {regex} `boolean` Use vim regex instead of lua pattern (see :help
                  pattern) (default true)
      {pattern} `string|fun(line: string): string` The lua pattern to use for
                matching, or test function

    Examples:
    Fail until a line starts with "panic:"
>
    {"test", "^panic:"}
<

--------------------------------------------------------------------------------
PARAMETERS                                                       *overseer-params*

Parameters are a schema-defined set of options. They are used by both components
and templates to expose customization options.

>lua
    local params = {
      my_var = {
        type = "string",
        -- Optional fields that are available on any type
        name = "More readable name",
        desc = "A detailed description",
        order = 1, -- determines order of parameters in the UI
        validate = function(value)
          return true,
        end,
        optional = true,
        default = "foobar",
        -- For component params only.
        -- When true, will default to the value in the task's default_component_params
        default_from_task = true,
      }
    }
<

The following types are available:

>lua
    {
      type = "string"
    }
    {
      type = "boolean"
    }
    {
      type = "number"
    }
    {
      type = "integer"
    }
    {
      type = "list",
      subtype = {
        type = "string"
      },
      delimiter = ",",
    }
    {
      type = "enum",
      choices = {"ONE", "TWO", "THREE"},
    }
    {
      -- This is used when the value is too complex to be represented or edited by the user in the task editor.
      -- It should generally only be used by components (which are usually configured programmatically)
      -- and not templates (which usually prompt the user for their parameters)
      type = "opaque"
    }
<

--------------------------------------------------------------------------------
ACTIONS                                                         *overseer-actions*

Actions can be performed on tasks by using the `RunAction` keybinding in the
task list, or by the `OverseerQuickAction` and `OverseerTaskAction` commands.
They are simply a custom function that will do something to or with a task.

Browse the set of built-in actions at lua/overseer/task_list/actions.lua

You can define your own or disable any of the built-in actions in the call to
setup():

>lua
    overseer.setup({
      actions = {
        ["My custom action"] = {
          desc = "This is an optional description. It may be omitted.",
          -- Optional function that will determine when this action is available
          condition = function(task)
            if task.name == "foobar" then
              return true
            else
              return false
            end
          end,
          run = function(task)
            -- Your custom logic here
          end,
        },
    
        -- Disable built-in actions by setting them to 'false'
        watch = false,
      },
      -- You can optionally add keymaps to run your action in the task list
      -- It will always be available in the "RunAction" menu, but it may be
      -- worth mapping it directly if you use it often.
      task_list = {
        bindings = {
          ['P'] = '<CMD>OverseerQuickAction My custom action<CR>',
        }
      }
    })
<

================================================================================
vim:tw=80:ts=2:ft=help:norl:syntax=help:
