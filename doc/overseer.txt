*overseer.txt*
*Overseer* *overseer* *overseer.nvim*
--------------------------------------------------------------------------------
CONTENTS                                                       *overseer-contents*

  1. Commands                                              |overseer-commands|
  2. Options                                                |overseer-options|
  3. Highlights                                          |overseer-highlights|
  4. Api                                                        |overseer-api|
  5. Components                                          |overseer-components|
  6. Strategies                                          |overseer-strategies|
  7. Parameters                                              |overseer-params|
  8. Actions                                                |overseer-actions|

--------------------------------------------------------------------------------
COMMANDS                                                       *overseer-commands*

OverseerOpen[!] `left/right/bottom`                                  *:OverseerOpen*
    Open the overseer window. With `!` cursor stays in current window

OverseerClose                                                     *:OverseerClose*
    Close the overseer window

OverseerToggle[!] `left/right/bottom`                              *:OverseerToggle*
    Toggle the overseer window. With `!` cursor stays in current window

OverseerRun `[name/tags]`                                             *:OverseerRun*
    Run a task from a template

OverseerShell `[command]`                                           *:OverseerShell*
    Run a shell command as an overseer task

OverseerQuickAction `[action]`                                *:OverseerQuickAction*
    Run an action on the most recent task, or the task under the cursor

OverseerTaskAction                                           *:OverseerTaskAction*
    Select a task to run an action on

--------------------------------------------------------------------------------
OPTIONS                                                         *overseer-options*

>lua
    require("overseer").setup({
      -- Patch nvim-dap to support preLaunchTask and postDebugTask
      dap = true,
      -- Overseer can hook vim.system and vim.fn.jobstart and display those as tasks
      hook_builtins = {
        enabled = true,
        condition = function(cmd, caller, opts)
          return true
        end,
      },
      -- Configure the task list
      task_list = {
        -- Default direction. Can be "left", "right", or "bottom"
        direction = "bottom",
        -- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_width and max_width can be a single value or a list of mixed integer/float types.
        -- max_width = {100, 0.2} means "the lesser of 100 columns or 20% of total"
        max_width = { 100, 0.2 },
        -- min_width = {40, 0.1} means "the greater of 40 columns or 10% of total"
        min_width = { 40, 0.1 },
        -- optionally define an integer/float for the exact width of the task list
        width = nil,
        max_height = { 20, 0.1 },
        min_height = 8,
        height = nil,
        -- String that separates tasks
        separator = "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
        -- Indentation for child tasks
        child_indent = { "┃ ", "┣━", "┗━" },
        -- Function that renders tasks. See lua/overseer/render.lua for built-in options
        -- and for useful functions if you want to build your own.
        render = function(task)
          return require("overseer.render").format_standard(task)
        end,
        -- The sort function for tasks
        sort = function(a, b)
          return require("overseer.task_list").default_sort(a, b)
        end,
        -- Set keymap to false to remove default behavior
        -- You can add custom keymaps here as well (anything vim.keymap.set accepts)
        bindings = {
          ["?"] = "ShowHelp",
          ["g?"] = "ShowHelp",
          ["<CR>"] = "RunAction",
          ["<C-e>"] = "Edit",
          ["o"] = "Open",
          ["<C-v>"] = "OpenVsplit",
          ["<C-s>"] = "OpenSplit",
          ["<C-f>"] = "OpenFloat",
          ["<C-q>"] = "OpenQuickFix",
          ["p"] = "TogglePreview",
          ["["] = "DecreaseWidth",
          ["]"] = "IncreaseWidth",
          ["{"] = "PrevTask",
          ["}"] = "NextTask",
          ["<C-k>"] = "ScrollOutputUp",
          ["<C-j>"] = "ScrollOutputDown",
          ["q"] = "Close",
        },
      },
      -- See :help overseer-actions
      actions = {},
      -- Configure the floating window used for task templates that require input
      -- and the floating window used for editing tasks
      form = {
        zindex = 40,
        -- Dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
        -- min_X and max_X can be a single value or a list of mixed integer/float types.
        min_width = 80,
        max_width = 0.9,
        width = nil,
        min_height = 10,
        max_height = 0.9,
        height = nil,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {
          winblend = 0,
        },
      },
      -- Configuration for task floating output windows
      task_win = {
        -- How much space to leave around the floating window
        padding = 2,
        -- Set any window options here (e.g. winhighlight)
        win_opts = {
          winblend = 0,
        },
      },
      -- Aliases for bundles of components. Redefine the builtins, or create your own.
      component_aliases = {
        -- Most tasks are initialized with the default components
        default = {
          "on_exit_set_status",
          "on_complete_notify",
          { "on_complete_dispose", require_view = { "SUCCESS", "FAILURE" } },
        },
        -- Tasks from tasks.json use these components
        default_vscode = {
          "default",
          "on_result_diagnostics",
        },
        -- Tasks created from vim.system or vim.fn.jobstart
        default_builtin = {
          "on_exit_set_status",
          "on_complete_dispose",
          { "unique", soft = true },
        },
      },
      -- List of other directories to search for task templates.
      -- This will search under the runtimepath, so for example
      -- "foo/bar" will search "<runtimepath>/lua/foo/bar/*"
      template_dirs = {},
      -- For template providers, how long to wait before timing out.
      -- Set to 0 to wait forever.
      template_timeout_ms = 3000,
      -- Cache template provider results if the provider takes longer than this to run.
      -- Set to 0 to disable caching.
      template_cache_threshold_ms = 200,
      log_level = vim.log.levels.WARN,
    })
<

--------------------------------------------------------------------------------
HIGHLIGHTS                                                   *overseer-highlights*

OverseerPENDING                                               *hl-OverseerPENDING*
    Pending tasks

OverseerRUNNING                                               *hl-OverseerRUNNING*
    Running tasks

OverseerSUCCESS                                               *hl-OverseerSUCCESS*
    Succeeded tasks

OverseerCANCELED                                             *hl-OverseerCANCELED*
    Canceled tasks

OverseerFAILURE                                               *hl-OverseerFAILURE*
    Failed tasks

OverseerTask                                                     *hl-OverseerTask*
    Used to render the name of a task or template

OverseerTaskBorder                                         *hl-OverseerTaskBorder*
    The separator in the task list

OverseerOutput                                                 *hl-OverseerOutput*
    The output summary in the task list

OverseerComponent                                           *hl-OverseerComponent*
    The name of a component in the task list or task editor

OverseerField                                                   *hl-OverseerField*
    The name of a field in the task or template editor

--------------------------------------------------------------------------------
API                                                                 *overseer-api*

setup({opts})                                                     *overseer.setup*
    Initialize overseer

    Parameters:
      {opts} `overseer.Config|nil` Configuration options

new_task({opts}): overseer.Task                                *overseer.new_task*
    Create a new Task

    Parameters:
      {opts} `overseer.TaskDefinition`
          {cmd}        `string|string[]` Command to run. If it's a string it is
                       run in the shell; a table is run directly
          {args}       `nil|string[]` Arguments to pass to the command
          {name}       `nil|string` Name of the task. Defaults to the cmd
          {cwd}        `nil|string` Working directory to run in
          {env}        `nil|table<string, string>` Additional environment
                       variables
          {strategy}   `nil|overseer.Serialized` Definition for a run Strategy
          {metadata}   `nil|table` Arbitrary metadata for your own use
          {default_component_params} `nil|table<string, any>` Default values for
                       component params
          {components} `nil|overseer.Serialized[]` List of components to attach.
                       Defaults to `{"default"}`

    Examples: >lua
      local task = overseer.new_task({
        cmd = { "./build.sh", "all" },
        components = { { "on_output_quickfix", open = true }, "default" }
      })
      task:start()
<

run_cmd({opts}, {callback})                                     *overseer.run_cmd*

    Parameters:
      {opts}     `nil|overseer.RunCmdOpts`
          {autostart} `nil|boolean`
      {callback} `nil|fun(task: nil|overseer.Task)`

toggle({opts})                                                   *overseer.toggle*
    Open or close the task list

    Parameters:
      {opts} `nil|overseer.WindowOpts`
          {enter}         `nil|boolean`
          {direction}     `nil|"left"|"right"|"bottom"`
          {winid}         `nil|integer` Use this existing window instead of
                          opening a new window
          {focus_task_id} `nil|integer` After opening, focus this task

open({opts})                                                       *overseer.open*
    Open the task list

    Parameters:
      {opts} `nil|overseer.WindowOpts`
          {enter}         `nil|boolean`
          {direction}     `nil|"left"|"right"|"bottom"`
          {winid}         `nil|integer` Use this existing window instead of
                          opening a new window
          {focus_task_id} `nil|integer` After opening, focus this task

close()                                                           *overseer.close*
    Close the task list


list_tasks({opts}): overseer.Task[]                          *overseer.list_tasks*
    List all tasks

    Parameters:
      {opts} `nil|overseer.ListTaskOpts`
          {unique}     `nil|boolean` Deduplicates non-running tasks by name
          {status}     `nil|overseer.Status|overseer.Status[]` Only list tasks
                       with this status or statuses
          {bundleable} `nil|boolean` Only list tasks that should be included in
                       a bundle
          {filter}     `nil|fun(task: overseer.Task): boolean`

run_task({opts}, {callback})                                   *overseer.run_task*
    Run a task from a template

    Parameters:
      {opts}     `overseer.TemplateRunOpts`
          {name}            `nil|string` The name of the template to run
          {tags}            `nil|string[]` List of tags used to filter when
                            searching for template
          {autostart}       `nil|boolean` When true, start the task after
                            creating it (default true)
          {first}           `nil|boolean` When true, take first result and never
                            show the task picker. Default behavior will auto-set
                            this based on presence of name and tags
          {params}          `nil|table` Parameters to pass to template
          {cwd}             `nil|string` Working directory for the task
          {env}             `nil|table<string, string>` Additional environment
                            variables for the task
          {disallow_prompt} `nil|boolean` When true, if any required parameters
                            are missing return an error instead of prompting the
                            user for them
          {on_build}        `nil|fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`
                            callback that is called after the task definition is
                            built but before the task is created.
      {callback} `nil|fun(task: overseer.Task|nil, err: string|nil)`

    Examples: >lua
      -- Run the task named "make all"
      -- equivalent to :OverseerRun make\ all
      overseer.run_task({name = "make all"})
      -- Run the default "build" task
      -- equivalent to :OverseerRun BUILD
      overseer.run_task({tags = {overseer.TAG.BUILD}})
      -- Run the task named "serve" with some default parameters
      overseer.run_task({name = "serve", params = {port = 8080}})
      -- Create a task but do not start it
      overseer.run_task({name = "make", autostart = false}, function(task)
        -- do something with the task
      end)
      -- Run a task and immediately open the floating window
      overseer.run_task({name = "make"}, function(task)
        if task then
          overseer.run_action(task, 'open float')
        end
      end)
<

preload_task_cache({opts}, {cb})                     *overseer.preload_task_cache*
    Preload templates for run_task

    Parameters:
      {opts} `nil|overseer.SearchParams`
          {filetype} `nil|string`
          {tags}     `nil|string[]`
          {dir}      `string`
      {cb}   `nil|fun()` Called when preloading is complete

    Note:
      Typically this would be done to prevent a long wait time for :OverseerRun when using a slow
      template provider.

    Examples: >lua
      -- Automatically preload templates for the current directory
      vim.api.nvim_create_autocmd({"VimEnter", "DirChanged"}, {
        local cwd = vim.v.cwd or vim.fn.getcwd()
        require("overseer").preload_task_cache({ dir = cwd })
      })
<

clear_task_cache({opts})                               *overseer.clear_task_cache*
    Clear cached templates for run_task

    Parameters:
      {opts} `nil|overseer.SearchParams`
          {filetype} `nil|string`
          {tags}     `nil|string[]`
          {dir}      `string`

run_action({task}, {name})                                   *overseer.run_action*
    Run an action on a task

    Parameters:
      {task} `overseer.Task`
      {name} `string|nil` Name of action. When omitted, prompt user to pick.

add_template_hook({opts}, {hook})                     *overseer.add_template_hook*
    Add a hook that runs on a TaskDefinition before the task is created

    Parameters:
      {opts} `nil|overseer.HookOptions` When nil, run the hook on all templates
          {module} `nil|string` Only run if the template module matches this
                   pattern (using string.match)
          {name}   `nil|string` Only run if the template name matches this
                   pattern (using string.match)
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      -- Add on_output_quickfix component to all "cargo" templates
      overseer.add_template_hook({ module = "^cargo$" }, function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end)
      -- Remove the on_complete_notify component from "cargo clean" task
      overseer.add_template_hook({ name = "cargo clean" }, function(task_defn, util)
        util.remove_component(task_defn, "on_complete_notify")
      end)
      -- Add an environment variable for all go tasks in a specific dir
      overseer.add_template_hook({ name = "^go .*", dir = "/path/to/project" }, function(task_defn, util)
        task_defn.env = vim.tbl_extend('force', task_defn.env or {}, {
          GO111MODULE = "on"
        })
      end)
<

remove_template_hook({opts}, {hook})               *overseer.remove_template_hook*
    Remove a hook that was added with add_template_hook

    Parameters:
      {opts} `nil|overseer.HookOptions` Same as for add_template_hook
          {module} `nil|string` Only run if the template module matches this
                   pattern (using string.match)
          {name}   `nil|string` Only run if the template name matches this
                   pattern (using string.match)
      {hook} `fun(task_defn: overseer.TaskDefinition, util: overseer.TaskUtil)`

    Examples: >lua
      local opts = {module = "cargo"}
      local hook = function(task_defn, util)
        util.add_component(task_defn, { "on_output_quickfix", open = true })
      end
      overseer.add_template_hook(opts, hook)
      -- Remove should pass in the same opts as add
      overseer.remove_template_hook(opts, hook)
<

register_template({defn})                             *overseer.register_template*
    Directly register an overseer template

    Parameters:
      {defn} `overseer.TemplateDefinition|overseer.TemplateProvider`

    Examples: >lua
      overseer.register_template({
        name = "My Task",
        builder = function(params)
          return {
            cmd = { "echo", "Hello", "world" },
          }
        end,
      })
<

register_alias({name}, {components})                     *overseer.register_alias*
    Register a new component alias.

    Parameters:
      {name}       `string`
      {components} `overseer.Serialized[]`

    Note:
      This is intended to be used by plugin authors that wish to build on top of overseer. They do not
      have control over the call to overseer.setup(), so this provides an alternative method of
      setting a component alias that they can then use when creating tasks.

    Examples: >lua
      require("overseer").register_alias("my_plugin", { "default", "on_output_quickfix" })
<

hook_builtins({enabled})                                  *overseer.hook_builtins*
    Hook vim.system and vim.fn.jobstart to display tasks in overseer

    Parameters:
      {enabled} `nil|boolean`

--------------------------------------------------------------------------------
COMPONENTS                                                   *overseer-components*

dependencies                                                        *dependencies*
    Set dependencies for task

    Parameters:
      {sequential} `boolean` (default `false`)
      {tasks}      `list[string]` Names of dependency task templates This can be
                   a list of strings (template names, e.g. "cargo build"),
                   tables (template name with params, e.g. {"mytask", foo =
                   "bar"}), or tables (raw task params, e.g. {cmd = "sleep 10"})

on_complete_dispose                                          *on_complete_dispose*
    After task is completed, dispose it after a timeout

    Parameters:
      {require_view} `list[enum]` Tasks with these statuses must be viewed
                     before they will be disposed (default `[]`)
      {statuses}     `list[enum]` Tasks with one of these statuses will be
                     disposed (default `["SUCCESS", "FAILURE", "CANCELED"]`)
      {timeout}      `number` Time to wait (in seconds) before disposing
                     (default `300`)

on_complete_notify                                            *on_complete_notify*
    vim.notify when task is completed

    Parameters:
      {on_change} `boolean` Only notify when task status changes from previous
                  value (default `false`) This is mostly used when a task is
                  going to be restarted, and you want notifications only when it
                  goes from SUCCESS to FAILURE, or vice-versa
      {statuses}  `list[enum]` List of statuses to notify on (default
                  `["FAILURE", "SUCCESS"]`)
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

on_complete_restart                                          *on_complete_restart*
    Restart task when it completes

    Parameters:
      {delay}    `number` How long to wait (in ms) post-result before triggering
                 restart (default `500`)
      {statuses} `list[enum]` What statuses will trigger a restart (default
                 `["FAILURE"]`)

on_exit_set_status                                            *on_exit_set_status*
    Sets final task status based on exit code

    Parameters:
      {success_codes} `list[integer]` Additional exit codes to consider as
                      success

on_output_notify                                                *on_output_notify*
    Use nvim-notify to show notification with task output summary for long-running tasks
    Works like on_complete_notify but, for long-running commands, also shows
    real-time output summary. Requires nvim-notify to modify the last
    notification window when new output arrives instead of creating new
    notification.

    Parameters:
      {delay_ms}  `number` Time in milliseconds to wait before displaying the
                  notification during task runtime (default `2000`)
      {max_lines} `integer` Number of lines of output to show (default `1`)
      {max_width} `integer` Maximum output width (default `49`)
      {output_on_complete} `boolean` Show the last lines of task output and
                  status on completion (instead of only the status) (default
                  `false`) When output_on_complete==true: shows status + last
                  output lines during task runtime and after completion. When
                  output_on_complete==false: shows status + last output lines
                  during task runtime and only status after completion.
      {trim}      `boolean` Remove whitespace from both sides of each line
                  (default `true`)

on_output_parse                                                  *on_output_parse*
    Parses task output and sets task result

    Parameters:
      {parser}          `opaque` Parse function or overseer.OutputParser This
                        can be a function that takes a line of output and
                        (optionally) returns a quickfix-list item (see :help
                        |setqflist-what|). For more complex parsing, this should
                        be a class of type overseer.OutputParser.
      {problem_matcher} `opaque` VS Code-style problem matcher Only one of
                        'parser', 'problem_matcher', or 'errorformat' is
                        allowed.
      {errorformat}     `opaque` Errorformat string Only one of 'parser',
                        'problem_matcher', or 'errorformat' is allowed.
      {precalculated_vars} `opaque` Precalculated VS Code task variables Tasks
                        that are started from the VS Code provider precalculate
                        certain interpolated variables (e.g.
                        ${workspaceFolder}). We pass those in as params so they
                        will remain stable even if Neovim's state changes in
                        between creating and running (or restarting) the task.
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)

on_output_quickfix                                            *on_output_quickfix*
    Set all task output into the quickfix (on complete)

    Parameters:
      {close}           `boolean` Close the quickfix on completion if no
                        errorformat matches (default `false`)
      {errorformat}     `string` See :help errorformat
      {items_only}      `boolean` Only show lines that match the errorformat
                        (default `false`)
      {open}            `boolean` Open the quickfix on output (default `false`)
      {open_height}     `integer` The height of the quickfix when opened
      {open_on_exit}    `enum` Open the quickfix when the command exits (default
                        `"never"`) (choices: `"never"|"failure"|"always"`)
      {open_on_match}   `boolean` Open the quickfix when the errorformat finds a
                        match (default `false`)
      {relative_file_root} `string` Relative filepaths will be joined to this
                        root (instead of task cwd)
      {set_diagnostics} `boolean` Add the matching items to vim.diagnostics
                        (default `false`)
      {tail}            `boolean` Update the quickfix with task output as it
                        happens, instead of waiting until completion (default
                        `true`) This may cause unexpected results for commands
                        that produce "fancy" output using terminal escape codes
                        (e.g. animated progress indicators)

on_output_write_file                                        *on_output_write_file*
    Write task output to a file

    Parameters:
      {*filename} `string` Name of file to write output to

on_result_diagnostics                                      *on_result_diagnostics*
    If task result contains diagnostics, display them

    Parameters:
      {remove_on_restart} `boolean` Remove diagnostics when task restarts
      {signs}        `boolean` Override the default diagnostics.signs setting
      {underline}    `boolean` Override the default diagnostics.underline
                     setting
      {virtual_text} `boolean` Override the default diagnostics.virtual_text
                     setting

on_result_diagnostics_quickfix                    *on_result_diagnostics_quickfix*
    If task result contains diagnostics, add them to the quickfix

    Parameters:
      {close}       `boolean` If true, close the quickfix when there are no
                    diagnostics (default `false`)
      {open}        `boolean` If true, open the quickfix when there are
                    diagnostics (default `false`)
      {set_empty_results} `boolean` If true, overwrite the current quickfix even
                    if there are no diagnostics (default `false`)
      {use_loclist} `boolean` If true, use the loclist instead of quickfix
                    (default `false`)

on_result_diagnostics_trouble                      *on_result_diagnostics_trouble*
    If task result contains diagnostics, open trouble.nvim

    Parameters:
      {args}  `list[string]` Arguments passed to 'Trouble diagnostics open'
      {close} `boolean` If true, close Trouble when there are no diagnostics
              (default `false`)

on_result_notify                                                *on_result_notify*
    vim.notify when task receives results
    Normally you will want to use on_complete_notify. If you have a long-running
    watch task (e.g. `tsc --watch`) that produces new results periodically, then
    this is the component you want.

    Parameters:
      {infer_status_from_diagnostics} `boolean` Notification level will be
                  error/info depending on if diagnostics are present (default
                  `true`)
      {on_change} `boolean` Only notify when status changes from previous value
                  (default `true`) This only works when
                  infer_status_from_diagnostics = true
      {system}    `enum` When to send a system notification (default `"never"`)
                  (choices: `"always"|"never"|"unfocused"`)

open_output                                                          *open_output*
    Open task output

    Parameters:
      {direction}   `enum` Where to open the task output (default `"dock"`) The
                    'dock' option will open the output docked to the bottom next
                    to the task list. (choices:
                    `"dock"|"float"|"tab"|"vertical"|"horizontal"`)
      {focus}       `boolean` Focus the output window when it is opened (default
                    `false`)
      {on_complete} `enum` Open the output when the task completes (default
                    `"never"`) (choices: `"always"|"never"|"success"|"failure"`)
      {on_result}   `enum` Open the output when the task produces a result
                    (default `"never"`) (choices:
                    `"always"|"never"|"if_diagnostics"`)
      {on_start}    `enum` Open the output when the task starts (default
                    `"if_no_on_output_quickfix"`) The 'if_no_on_output_quickfix'
                    option will open the task output on start unless the task
                    has the 'on_output_quickfix' component attached. (choices:
                    `"always"|"never"|"if_no_on_output_quickfix"`)

restart_on_save                                                  *restart_on_save*
    Restart on any buffer :write

    Parameters:
      {delay}     `number` How long to wait (in ms) before triggering restart
                  (default `500`)
      {interrupt} `boolean` Interrupt running tasks. If false, will wait for
                  task to complete before restarting (default `true`)
      {mode}      `enum` How to watch the paths (default `"autocmd"`) 'autocmd'
                  will set autocmds on BufWritePost. 'uv' will use a libuv file
                  watcher (recursive watching may not be supported on all
                  platforms). (choices: `"autocmd"|"uv"`)
      {paths}     `list[string]` Only restart when writing files in these paths
                  (can be directory or file)

run_after                                                              *run_after*
    Run other tasks after this task completes

    Parameters:
      {detach}   `boolean` Tasks created will not be linked to the parent task
                 (default `false`) This means they will not restart when the
                 parent restarts, and will not be disposed when the parent is
                 disposed
      {statuses} `list[enum]` Only run successive tasks if the final status is
                 in this list (default `["SUCCESS"]`)
      {tasks}    `list[string]` Names of dependency task templates This can be a
                 list of strings (template names, e.g. "cargo build"), tables
                 (template name with params, e.g. {"mytask", foo = "bar"}), or
                 tables (raw task params, e.g. {cmd = "sleep 10"})

timeout                                                                  *timeout*
    Cancel task if it exceeds a timeout

    Parameters:
      {timeout} `integer` Time to wait (in seconds) before canceling (default
                `120`)

unique                                                                    *unique*
    Ensure that this task does not have any duplicates

    Parameters:
      {replace} `boolean` If a prior task exists, replace it. When false, will
                restart the existing task and dispose the current task (default
                `true`) Note that when this is false a new task that is created
                will restart the existing one and _dispose itself_. This can
                lead to unexpected behavior if you are creating a task and then
                trying to use that reference (to run actions on it, use it as a
                dependency, etc)
      {restart_interrupts} `boolean` When replace = false, should restarting the
                existing task interrupt it (default `true`)
      {soft}    `boolean` Only dispose duplicate tasks if they are completed.
                Implies replace = true. (default `false`)

--------------------------------------------------------------------------------
STRATEGIES                                                   *overseer-strategies*

jobstart({opts}): overseer.Strategy                            *strategy.jobstart*
    Run tasks using jobstart()

    Parameters:
      {opts} `nil|overseer.JobstartStrategyOpts`
          {preserve_output} `nil|boolean` If true, don't clear the buffer when
                            tasks restart
          {use_terminal}    `nil|boolean` If false, use a normal non-terminal
                            buffer to store the output. This may produce
                            unwanted results if the task outputs terminal escape
                            sequences.
          {wrap_opts}       `nil|table` Opts that were passed to jobstart(). We
                            should wrap them

orchestrator({opts}): overseer.Strategy                    *strategy.orchestrator*
    Strategy for a meta-task that manage a sequence of other tasks

    Parameters:
      {opts} `table`
          {tasks} `table` A list of task definitions to run. Can include sub-
                  lists that will be run in parallel

    Examples: >lua
      overseer.new_task({
        name = "Build and serve app",
        strategy = {
          "orchestrator",
          tasks = {
            "make clean", -- Step 1: clean
            {             -- Step 2: build js and css in parallel
               "npm build",
              { cmd = {"lessc", "styles.less", "styles.css"} },
            },
            "npm serve",  -- Step 3: serve
          },
        },
      })
<

system({opts}): overseer.Strategy                                *strategy.system*

    Parameters:
      {opts} `nil|overseer.SystemStrategyOpts`
          {wrap_opts} `nil|vim.SystemOpts` Opts that were passed to
                      vim.system(). We should wrap them
          {wrap_exit} `nil|fun(out: vim.SystemCompleted)`

test(): overseer.Strategy                                          *strategy.test*
    Strategy used for unit testing

--------------------------------------------------------------------------------
PARAMETERS                                                       *overseer-params*

Parameters are a schema-defined set of options. They are used by both components
and templates to expose customization options.

>lua
    local params = {
      my_var = {
        type = "string",
        -- Optional fields that are available on any type
        name = "More readable name",
        desc = "A detailed description",
        order = 1, -- determines order of parameters in the UI
        validate = function(value)
          return true
        end,
        optional = true,
        default = "foobar",
        -- For component params only.
        -- When true, will default to the value in the task's default_component_params
        default_from_task = true,
      }
    }
<

The following types are available:

>lua
    {
      type = "string"
    }
    {
      type = "boolean"
    }
    {
      type = "number"
    }
    {
      type = "integer"
    }
    {
      type = "list",
      subtype = {
        type = "string"
      },
      delimiter = ",",
    }
    {
      type = "enum",
      choices = {"ONE", "TWO", "THREE"},
    }
    {
      -- This is used when the value is too complex to be represented or edited by the user in the task editor.
      -- It should generally only be used by components (which are usually configured programmatically)
      -- and not templates (which usually prompt the user for their parameters)
      type = "opaque"
    }
<

Templates can define params to be a function, to dynamically generate the
params.

>lua
    require("overseer").register_template({
      name = "Git checkout",
      params = function()
        local stdout = vim.system({ "git", "branch", "--format=%(refname:short)" }):wait().stdout
        local branches = vim.split(stdout, "\n", { trimempty = true })
        return {
          branch = {
            desc = "Branch to checkout",
            type = "enum",
            choices = branches,
          },
        }
      end,
      builder = function(params)
        return {
          cmd = { "git", "checkout", params.branch },
        }
      end,
    })
<

--------------------------------------------------------------------------------
ACTIONS                                                         *overseer-actions*

Actions can be performed on tasks by using the `RunAction` keybinding in the
task list, or by the `OverseerQuickAction` and `OverseerTaskAction` commands.
They are simply a custom function that will do something to or with a task.

Browse the set of built-in actions at lua/overseer/task_list/actions.lua

You can define your own or disable any of the built-in actions in the call to
setup():

>lua
    overseer.setup({
      actions = {
        ["My custom action"] = {
          desc = "This is an optional description. It may be omitted.",
          -- Optional function that will determine when this action is available
          condition = function(task)
            if task.name == "foobar" then
              return true
            else
              return false
            end
          end,
          run = function(task)
            -- Your custom logic here
          end,
        },
    
        -- Disable built-in actions by setting them to 'false'
        watch = false,
      },
      -- You can optionally add keymaps to run your action in the task list
      -- It will always be available in the "RunAction" menu, but it may be
      -- worth mapping it directly if you use it often.
      task_list = {
        bindings = {
          ["P"] = "<CMD>OverseerQuickAction My custom action<CR>",
        },
      },
    })
<

================================================================================
vim:tw=80:ts=2:ft=help:norl:syntax=help:
